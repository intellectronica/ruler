import * as fs from "fs/promises";
import * as path from "path";
import * as os from "os";
import { AgentsMdAgent } from "../../../src/agents/AgentsMdAgent";
import { WindsurfAgent } from "../../../src/agents/WindsurfAgent";
import { readMarkdownFiles } from "../../../src/core/FileSystemUtils";

/**
 * Test for the specific issue mentioned in the comment:
 * "the fix isn't working. The notification `<!-- Generated by Skiller -->` is added to `AGENTS.md`,
 * but the generated `.windsurf/rules/skiller_windsurf_instructions.md` still has the duplication."
 */
describe("Consecutive applies duplication prevention", () => {
	let tmpDir: string;
	let skillerDir: string;
	let projectRoot: string;
	let agentsMdAgent: AgentsMdAgent;
	let windsurfAgent: WindsurfAgent;

	beforeEach(async () => {
		tmpDir = await fs.mkdtemp(
			path.join(os.tmpdir(), "skiller-consecutive-test-"),
		);
		projectRoot = tmpDir;
		skillerDir = path.join(tmpDir, ".claude");
		await fs.mkdir(skillerDir, { recursive: true });

		agentsMdAgent = new AgentsMdAgent();
		windsurfAgent = new WindsurfAgent();
	});

	afterEach(async () => {
		await fs.rm(tmpDir, { recursive: true, force: true });
	});

	it("should not duplicate content in windsurf output on consecutive applies", async () => {
		// Step 1: Create initial skiller content
		const initialSkillerContent =
			"Initial skiller instructions from .claude directory.";
		await fs.writeFile(
			path.join(skillerDir, "instructions.md"),
			initialSkillerContent,
		);

		// Step 2: Simulate first apply - read markdown files and generate content
		let markdownFiles = await readMarkdownFiles(skillerDir);
		let concatenatedRules = markdownFiles.map((f) => f.content).join("\n\n");

		// First apply - generate AGENTS.md
		await agentsMdAgent.applySkillerConfig(concatenatedRules, projectRoot, null);

		// First apply - generate windsurf output
		const windsurfOutputPath = windsurfAgent.getDefaultOutputPath(projectRoot);
		await windsurfAgent.applySkillerConfig(concatenatedRules, projectRoot, null);

		// Read the first windsurf output
		const firstWindsurfOutput = await fs.readFile(windsurfOutputPath, "utf8");

		// Step 3: Simulate second apply - this should NOT cause duplication
		markdownFiles = await readMarkdownFiles(skillerDir);
		concatenatedRules = markdownFiles.map((f) => f.content).join("\n\n");

		// Second apply - should not change AGENTS.md (idempotent)
		await agentsMdAgent.applySkillerConfig(concatenatedRules, projectRoot, null);

		// Second apply - should not duplicate content in windsurf output
		await windsurfAgent.applySkillerConfig(concatenatedRules, projectRoot, null);

		// Read the second windsurf output
		const secondWindsurfOutput = await fs.readFile(windsurfOutputPath, "utf8");

		// The windsurf output should be identical (no duplication)
		expect(secondWindsurfOutput).toBe(firstWindsurfOutput);

		// The concatenated rules should only contain the original skiller content once
		expect(concatenatedRules).toBe(initialSkillerContent);
		expect(concatenatedRules).not.toMatch(
			/Initial skiller instructions.*Initial skiller instructions/s,
		);

		// Verify AGENTS.md has the marker
		const agentsMdContent = await fs.readFile(
			path.join(projectRoot, "AGENTS.md"),
			"utf8",
		);
		expect(agentsMdContent).toMatch(/^<!-- Generated by Skiller -->/);
	});

	it("should handle multiple consecutive applies without exponential growth", async () => {
		// Create initial skiller content
		const initialSkillerContent = "Base skiller content.";
		await fs.writeFile(path.join(skillerDir, "AGENTS.md"), initialSkillerContent);

		const expectedLength = initialSkillerContent.length;
		let previousLength = 0;

		// Perform 3 consecutive applies
		for (let i = 0; i < 3; i++) {
			const markdownFiles = await readMarkdownFiles(skillerDir);
			const concatenatedRules = markdownFiles
				.map((f) => f.content)
				.join("\n\n");

			// Apply to both agents
			await agentsMdAgent.applySkillerConfig(
				concatenatedRules,
				projectRoot,
				null,
			);
			await windsurfAgent.applySkillerConfig(
				concatenatedRules,
				projectRoot,
				null,
			);

			// Check that concatenated rules length is stable
			expect(concatenatedRules.length).toBe(expectedLength);

			if (i > 0) {
				expect(concatenatedRules.length).toBe(previousLength);
			}
			previousLength = concatenatedRules.length;
		}
	});

	it("should reproduce the exact bug: duplication when only AGENTS.md exists in .claude", async () => {
		// This test reproduces the exact scenario that causes the bug

		// Step 1: Start with only AGENTS.md in .claude directory (common scenario)
		const originalSkillerContent = "Original content in .claude/AGENTS.md";
		await fs.writeFile(path.join(skillerDir, "AGENTS.md"), originalSkillerContent);

		// Step 2: First apply - this should work fine
		let markdownFiles = await readMarkdownFiles(skillerDir);
		let concatenatedRules = markdownFiles.map((f) => f.content).join("\n\n");

		// Generate the root AGENTS.md with marker
		await agentsMdAgent.applySkillerConfig(concatenatedRules, projectRoot, null);

		// Apply to windsurf agent
		await windsurfAgent.applySkillerConfig(concatenatedRules, projectRoot, null);
		const windsurfPath = windsurfAgent.getDefaultOutputPath(projectRoot);
		const firstWindsurfOutput = await fs.readFile(windsurfPath, "utf8");

		// Step 3: Second apply - this is where the bug happens
		// The generated root AGENTS.md should be skipped, but isn't because the logic is wrong
		markdownFiles = await readMarkdownFiles(skillerDir);
		concatenatedRules = markdownFiles.map((f) => f.content).join("\n\n");

		// This should NOT contain duplicate content
		expect(concatenatedRules).toBe(originalSkillerContent);
		expect(concatenatedRules).not.toContain("<!-- Generated by Skiller -->");

		// Apply to windsurf agent again
		await windsurfAgent.applySkillerConfig(concatenatedRules, projectRoot, null);
		const secondWindsurfOutput = await fs.readFile(windsurfPath, "utf8");

		// The windsurf output should be identical (no duplication)
		expect(secondWindsurfOutput).toBe(firstWindsurfOutput);
	});

	it("should demonstrate the ACTUAL bug: empty skiller directory case", async () => {
		// This might be the real bug - when .claude has NO files initially

		// Step 1: Start with an empty .claude directory
		// (No files in .claude)

		// But let's say we have some global or other source of rules
		const someInitialRules = "Some initial rules from somewhere";

		// Step 2: Simulate first apply with some rules
		await agentsMdAgent.applySkillerConfig(someInitialRules, projectRoot, null);

		// Now create a file in .claude after the first apply
		await fs.writeFile(
			path.join(skillerDir, "instructions.md"),
			"New skiller instructions",
		);

		// Step 3: Second apply - now .claude has files, but root AGENTS.md is generated
		let markdownFiles = await readMarkdownFiles(skillerDir);
		let concatenatedRules = markdownFiles.map((f) => f.content).join("\n\n");

		// The concatenated rules should only contain the new skiller instructions, not the generated content
		expect(concatenatedRules).toBe("New skiller instructions");
		expect(concatenatedRules).not.toContain("<!-- Generated by Skiller -->");
		expect(concatenatedRules).not.toContain(someInitialRules);
	});

	it("should try to reproduce the actual bug scenario", async () => {
		// Maybe the bug happens in a very specific scenario
		// Let me try to create a test that might fail

		// Scenario: Start with some content, apply, then add more content, apply again
		console.log("\n=== REPRODUCING EXACT BUG ===");

		// Step 1: Start with empty .claude but some other source of rules
		// (Simulate some initial state)

		// Step 2: Create a file that will cause the first generation
		const initialContent = "You are helpful.";
		await fs.writeFile(path.join(skillerDir, "base.md"), initialContent);

		// First apply
		let files = await readMarkdownFiles(skillerDir);
		let rules = files.map((f) => f.content).join("\n\n");
		await agentsMdAgent.applySkillerConfig(rules, projectRoot, null);
		await windsurfAgent.applySkillerConfig(rules, projectRoot, null);

		const windsurfPath = windsurfAgent.getDefaultOutputPath(projectRoot);
		const firstContent = await fs.readFile(windsurfPath, "utf8");
		console.log(
			"After first apply - windsurf content:",
			JSON.stringify(firstContent),
		);

		// Check the root AGENTS.md
		const agentsMdPath = path.join(projectRoot, "AGENTS.md");
		const rootContent1 = await fs.readFile(agentsMdPath, "utf8");
		console.log(
			"After first apply - root AGENTS.md:",
			JSON.stringify(rootContent1),
		);

		// Step 3: Add more content to .claude directory
		const additionalContent = "Be concise in responses.";
		await fs.writeFile(path.join(skillerDir, "additional.md"), additionalContent);

		// Second apply - this should NOT duplicate the previous content
		files = await readMarkdownFiles(skillerDir);
		console.log("Files found on second read:");
		files.forEach((f) =>
			console.log(`  - ${f.path}: ${JSON.stringify(f.content)}`),
		);

		rules = files.map((f) => f.content).join("\n\n");
		console.log("Concatenated rules on second apply:", JSON.stringify(rules));

		await agentsMdAgent.applySkillerConfig(rules, projectRoot, null);
		await windsurfAgent.applySkillerConfig(rules, projectRoot, null);

		const secondContent = await fs.readFile(windsurfPath, "utf8");
		console.log(
			"After second apply - windsurf content:",
			JSON.stringify(secondContent),
		);

		const rootContent2 = await fs.readFile(agentsMdPath, "utf8");
		console.log(
			"After second apply - root AGENTS.md:",
			JSON.stringify(rootContent2),
		);

		// Check for duplication
		const helpfulCount = (secondContent.match(/You are helpful/g) || []).length;
		expect(helpfulCount).toBe(1); // Should only appear once
	});
});
