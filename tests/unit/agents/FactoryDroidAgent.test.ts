import { promises as fs } from 'fs';
import * as path from 'path';
import os from 'os';

import { FactoryDroidAgent } from '../../../src/agents/FactoryDroidAgent';

describe('FactoryDroidAgent', () => {
  let tmpDir: string;

  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-factory-'));
  });

  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });

  it('returns correct identifier and name', () => {
    const agent = new FactoryDroidAgent();
    expect(agent.getIdentifier()).toBe('factory');
    expect(agent.getName()).toBe('Factory Droid');
  });

  it('writes AGENTS.md with marker comment', async () => {
    const agent = new FactoryDroidAgent();
    const target = path.join(tmpDir, 'AGENTS.md');

    await agent.applyRulerConfig('Factory rules', tmpDir, null);

    const written = await fs.readFile(target, 'utf8');
    expect(written).toBe('<!-- Generated by Ruler -->\nFactory rules');
  });

  it('returns correct default output path', () => {
    const agent = new FactoryDroidAgent();
    expect(agent.getDefaultOutputPath(tmpDir)).toBe(
      path.join(tmpDir, 'AGENTS.md'),
    );
  });

  it('supports MCP stdio and remote with mcpServers key', () => {
    const agent = new FactoryDroidAgent();
    expect(agent.supportsMcpStdio()).toBe(true);
    expect(agent.supportsMcpRemote()).toBe(true);
    expect(agent.getMcpServerKey()).toBe('mcpServers');
  });

  it('supports native skills', () => {
    const agent = new FactoryDroidAgent();
    expect(agent.supportsNativeSkills()).toBe(true);
  });
});
