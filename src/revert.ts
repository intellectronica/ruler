import * as path from 'path';
import { promises as fs } from 'fs';
import * as FileSystemUtils from './core/FileSystemUtils';
import { loadConfig } from './core/ConfigLoader';
import { IAgent } from './agents/IAgent';
import { CopilotAgent } from './agents/CopilotAgent';
import { ClaudeAgent } from './agents/ClaudeAgent';
import { CodexCliAgent } from './agents/CodexCliAgent';
import { CursorAgent } from './agents/CursorAgent';
import { WindsurfAgent } from './agents/WindsurfAgent';
import * as ClineAgent from './agents/ClineAgent';
import { AiderAgent } from './agents/AiderAgent';
import { FirebaseAgent } from './agents/FirebaseAgent';
import { OpenHandsAgent } from './agents/OpenHandsAgent';
import { GeminiCliAgent } from './agents/GeminiCliAgent';
import { JulesAgent } from './agents/JulesAgent';
import { JunieAgent } from './agents/JunieAgent';
import { AugmentCodeAgent } from './agents/AugmentCodeAgent';
import { KiloCodeAgent } from './agents/KiloCodeAgent';
import { OpenCodeAgent } from './agents/OpenCodeAgent';
import { GooseAgent } from './agents/GooseAgent';
import { AmpAgent } from './agents/AmpAgent';
import { getNativeMcpPath } from './paths/mcp';
import { IAgentConfig } from './agents/IAgent';
import { createRulerError, logVerbose } from './constants';
import {
  readVSCodeSettings,
  writeVSCodeSettings,
  getVSCodeSettingsPath,
} from './vscode/settings';

const agents: IAgent[] = [
  new CopilotAgent(),
  new ClaudeAgent(),
  new CodexCliAgent(),
  new CursorAgent(),
  new WindsurfAgent(),
  new ClineAgent.ClineAgent(),
  new AiderAgent(),
  new FirebaseAgent(),
  new OpenHandsAgent(),
  new GeminiCliAgent(),
  new JulesAgent(),
  new JunieAgent(),
  new AugmentCodeAgent(),
  new KiloCodeAgent(),
  new OpenCodeAgent(),
  new GooseAgent(),
  new AmpAgent(),
];

/**
 * Gets all output paths for an agent, taking into account any config overrides.
 * This is a copy of the function from lib.ts to maintain consistency.
 */
function getAgentOutputPaths(
  agent: IAgent,
  projectRoot: string,
  agentConfig?: IAgentConfig,
): string[] {
  const paths: string[] = [];
  const defaults = agent.getDefaultOutputPath(projectRoot);

  if (typeof defaults === 'string') {
    const actualPath = agentConfig?.outputPath ?? defaults;
    paths.push(actualPath);
  } else {
    const defaultPaths = defaults as Record<string, string>;

    if ('instructions' in defaultPaths) {
      const instructionsPath =
        agentConfig?.outputPathInstructions ?? defaultPaths.instructions;
      paths.push(instructionsPath);
    }

    if ('config' in defaultPaths) {
      const configPath = agentConfig?.outputPathConfig ?? defaultPaths.config;
      paths.push(configPath);
    }

    for (const [key, defaultPath] of Object.entries(defaultPaths)) {
      if (key !== 'instructions' && key !== 'config') {
        paths.push(defaultPath);
      }
    }
  }

  return paths;
}

/**
 * Checks if a file exists.
 */
async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Restores a file from its backup if the backup exists.
 */
async function restoreFromBackup(
  filePath: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<boolean> {
  const backupPath = `${filePath}.bak`;
  const backupExists = await fileExists(backupPath);

  if (!backupExists) {
    logVerbose(`No backup found for: ${filePath}`, verbose);
    return false;
  }

  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  if (dryRun) {
    logVerbose(
      `${actionPrefix} Would restore: ${filePath} from backup`,
      verbose,
    );
  } else {
    await fs.copyFile(backupPath, filePath);
    logVerbose(`${actionPrefix} Restored: ${filePath} from backup`, verbose);
  }

  return true;
}

/**
 * Removes a file if it exists and has no backup (meaning it was generated by ruler).
 */
async function removeGeneratedFile(
  filePath: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<boolean> {
  const fileExistsFlag = await fileExists(filePath);
  const backupExists = await fileExists(`${filePath}.bak`);

  if (!fileExistsFlag) {
    logVerbose(`File does not exist: ${filePath}`, verbose);
    return false;
  }

  if (backupExists) {
    logVerbose(`File has backup, skipping removal: ${filePath}`, verbose);
    return false;
  }

  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  if (dryRun) {
    logVerbose(
      `${actionPrefix} Would remove generated file: ${filePath}`,
      verbose,
    );
  } else {
    await fs.unlink(filePath);
    logVerbose(`${actionPrefix} Removed generated file: ${filePath}`, verbose);
  }

  return true;
}

/**
 * Removes backup files.
 */
async function removeBackupFile(
  filePath: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<boolean> {
  const backupPath = `${filePath}.bak`;
  const backupExists = await fileExists(backupPath);

  if (!backupExists) {
    return false;
  }

  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  if (dryRun) {
    logVerbose(
      `${actionPrefix} Would remove backup file: ${backupPath}`,
      verbose,
    );
  } else {
    await fs.unlink(backupPath);
    logVerbose(`${actionPrefix} Removed backup file: ${backupPath}`, verbose);
  }

  return true;
}

/**
 * Recursively checks if a directory contains only empty directories
 */
async function isDirectoryTreeEmpty(dirPath: string): Promise<boolean> {
  try {
    const entries = await fs.readdir(dirPath);
    if (entries.length === 0) {
      return true;
    }

    for (const entry of entries) {
      const entryPath = path.join(dirPath, entry);
      const entryStat = await fs.stat(entryPath);

      if (entryStat.isFile()) {
        return false;
      } else if (entryStat.isDirectory()) {
        const isEmpty = await isDirectoryTreeEmpty(entryPath);
        if (!isEmpty) {
          return false;
        }
      }
    }

    return true;
  } catch {
    return false;
  }
}

/**
 * Helper function to execute directory removal with consistent dry-run handling and logging.
 */
async function executeDirectoryAction(
  dirPath: string,
  action: 'remove' | 'remove-tree',
  verbose: boolean,
  dryRun: boolean,
): Promise<boolean> {
  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';
  const actionText = action === 'remove-tree' ? 'directory tree' : 'directory';

  if (dryRun) {
    logVerbose(
      `${actionPrefix} Would remove empty ${actionText}: ${dirPath}`,
      verbose,
    );
  } else {
    await fs.rm(dirPath, { recursive: true });
    logVerbose(
      `${actionPrefix} Removed empty ${actionText}: ${dirPath}`,
      verbose,
    );
  }
  return true;
}

/**
 * Attempts to remove a single empty directory if it exists and is empty.
 */
async function removeEmptyDirectory(
  dirPath: string,
  verbose: boolean,
  dryRun: boolean,
  logMissing = false,
): Promise<boolean> {
  try {
    const stat = await fs.stat(dirPath);
    if (!stat.isDirectory()) {
      return false;
    }

    const isEmpty = await isDirectoryTreeEmpty(dirPath);
    if (isEmpty) {
      return await executeDirectoryAction(
        dirPath,
        'remove-tree',
        verbose,
        dryRun,
      );
    }
    return false;
  } catch {
    if (logMissing) {
      logVerbose(
        `Directory ${dirPath} doesn't exist or can't be accessed`,
        verbose,
      );
    }
    return false;
  }
}

/**
 * Handles special cleanup logic for .augment directory and its rules subdirectory.
 */
async function removeAugmentDirectory(
  projectRoot: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<number> {
  const augmentDir = path.join(projectRoot, '.augment');
  let directoriesRemoved = 0;

  try {
    const augmentStat = await fs.stat(augmentDir);
    if (!augmentStat.isDirectory()) {
      return 0;
    }

    const rulesDir = path.join(augmentDir, 'rules');
    const rulesRemoved = await removeEmptyDirectory(rulesDir, verbose, dryRun);
    if (rulesRemoved) {
      directoriesRemoved++;
    }

    const augmentRemoved = await removeEmptyDirectory(
      augmentDir,
      verbose,
      dryRun,
    );
    if (augmentRemoved) {
      directoriesRemoved++;
    }
  } catch {
    // .augment directory doesn't exist, that's fine. leaving comment as catch block can't be kept empty.
  }

  return directoriesRemoved;
}

/**
 * Removes empty directories that were created by ruler.
 * Only removes directories if they are empty and were likely created by ruler.
 * Special handling for .augment directory to clean up rules subdirectory.
 */
async function removeEmptyDirectories(
  projectRoot: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<number> {
  const rulerCreatedDirs = [
    '.github',
    '.cursor',
    '.windsurf',
    '.junie',
    '.openhands',
    '.idx',
    '.gemini',
    '.vscode',
    '.augmentcode',
    '.kilocode',
  ];

  let directoriesRemoved = 0;

  // Handle .augment directory with special logic
  directoriesRemoved += await removeAugmentDirectory(
    projectRoot,
    verbose,
    dryRun,
  );

  // Handle all other ruler-created directories
  for (const dirName of rulerCreatedDirs) {
    const dirPath = path.join(projectRoot, dirName);
    const removed = await removeEmptyDirectory(dirPath, verbose, dryRun, true);
    if (removed) {
      directoriesRemoved++;
    }
  }

  return directoriesRemoved;
}

/**
 * Removes additional files created by specific agents that aren't covered by their main output paths.
 */
async function removeAdditionalAgentFiles(
  projectRoot: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<number> {
  const additionalFiles = [
    '.gemini/settings.json',
    '.mcp.json',
    '.vscode/mcp.json',
    '.cursor/mcp.json',
    '.kilocode/mcp.json',
    '.openhands/config.toml',
  ];

  let filesRemoved = 0;
  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  for (const filePath of additionalFiles) {
    const fullPath = path.join(projectRoot, filePath);

    try {
      const fileExistsFlag = await fileExists(fullPath);
      if (!fileExistsFlag) {
        continue;
      }

      const backupExists = await fileExists(`${fullPath}.bak`);
      if (backupExists) {
        const restored = await restoreFromBackup(fullPath, verbose, dryRun);
        if (restored) {
          filesRemoved++;
        }
      } else {
        if (dryRun) {
          logVerbose(
            `${actionPrefix} Would remove additional file: ${fullPath}`,
            verbose,
          );
        } else {
          await fs.unlink(fullPath);
          logVerbose(
            `${actionPrefix} Removed additional file: ${fullPath}`,
            verbose,
          );
        }
        filesRemoved++;
      }
    } catch {
      logVerbose(
        `Additional file ${fullPath} doesn't exist or can't be accessed`,
        verbose,
      );
    }
  }

  const settingsPath = getVSCodeSettingsPath(projectRoot);
  const backupPath = `${settingsPath}.bak`;

  if (await fileExists(backupPath)) {
    const restored = await restoreFromBackup(settingsPath, verbose, dryRun);
    if (restored) {
      filesRemoved++;
      logVerbose(
        `${actionPrefix} Restored VSCode settings from backup`,
        verbose,
      );
    }
  } else if (await fileExists(settingsPath)) {
    try {
      if (dryRun) {
        const settings = await readVSCodeSettings(settingsPath);
        if (settings['augment.advanced']) {
          delete settings['augment.advanced'];
          const remainingKeys = Object.keys(settings);
          if (remainingKeys.length === 0) {
            logVerbose(
              `${actionPrefix} Would remove empty VSCode settings file`,
              verbose,
            );
          } else {
            logVerbose(
              `${actionPrefix} Would remove augment.advanced section from ${settingsPath}`,
              verbose,
            );
          }
          filesRemoved++;
        }
      } else {
        const settings = await readVSCodeSettings(settingsPath);
        if (settings['augment.advanced']) {
          delete settings['augment.advanced'];

          const remainingKeys = Object.keys(settings);
          if (remainingKeys.length === 0) {
            await fs.unlink(settingsPath);
            logVerbose(
              `${actionPrefix} Removed empty VSCode settings file`,
              verbose,
            );
          } else {
            await writeVSCodeSettings(settingsPath, settings);
            logVerbose(
              `${actionPrefix} Removed augment.advanced section from VSCode settings`,
              verbose,
            );
          }
          filesRemoved++;
        } else {
          logVerbose(
            `No augment.advanced section found in ${settingsPath}`,
            verbose,
          );
        }
      }
    } catch (error) {
      logVerbose(`Failed to process VSCode settings.json: ${error}`, verbose);
    }
  }

  return filesRemoved;
}

/**
 * Removes the ruler-managed block from .gitignore file.
 */
async function cleanGitignore(
  projectRoot: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<boolean> {
  const gitignorePath = path.join(projectRoot, '.gitignore');
  const gitignoreExists = await fileExists(gitignorePath);

  if (!gitignoreExists) {
    logVerbose('No .gitignore file found', verbose);
    return false;
  }

  const content = await fs.readFile(gitignorePath, 'utf8');
  const startMarker = '# START Ruler Generated Files';
  const endMarker = '# END Ruler Generated Files';

  const startIndex = content.indexOf(startMarker);
  const endIndex = content.indexOf(endMarker);

  if (startIndex === -1 || endIndex === -1) {
    logVerbose('No ruler-managed block found in .gitignore', verbose);
    return false;
  }

  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  if (dryRun) {
    logVerbose(
      `${actionPrefix} Would remove ruler block from .gitignore`,
      verbose,
    );
  } else {
    const beforeBlock = content.substring(0, startIndex);
    const afterBlock = content.substring(endIndex + endMarker.length);

    let newContent = beforeBlock + afterBlock;
    newContent = newContent.replace(/\n{3,}/g, '\n\n'); // Replace 3+ newlines with 2

    if (newContent.trim() === '') {
      await fs.unlink(gitignorePath);
      logVerbose(`${actionPrefix} Removed empty .gitignore file`, verbose);
    } else {
      await fs.writeFile(gitignorePath, newContent);
      logVerbose(
        `${actionPrefix} Removed ruler block from .gitignore`,
        verbose,
      );
    }
  }

  return true;
}

/**
 * Reverts ruler configurations for selected AI agents.
 */
export async function revertAllAgentConfigs(
  projectRoot: string,
  includedAgents?: string[],
  configPath?: string,
  keepBackups = false,
  verbose = false,
  dryRun = false,
  localOnly = false,
): Promise<void> {
  logVerbose(
    `Loading configuration for revert from project root: ${projectRoot}`,
    verbose,
  );

  const config = await loadConfig({
    projectRoot,
    cliAgents: includedAgents,
    configPath,
  });

  const rulerDir = await FileSystemUtils.findRulerDir(projectRoot, !localOnly);
  if (!rulerDir) {
    throw createRulerError(
      `.ruler directory not found`,
      `Searched from: ${projectRoot}`,
    );
  }
  logVerbose(`Found .ruler directory at: ${rulerDir}`, verbose);

  const rawConfigs = config.agentConfigs;
  const mappedConfigs: Record<string, (typeof rawConfigs)[string]> = {};
  for (const [key, cfg] of Object.entries(rawConfigs)) {
    const lowerKey = key.toLowerCase();
    for (const agent of agents) {
      const identifier = agent.getIdentifier();
      if (
        identifier === lowerKey ||
        agent.getName().toLowerCase().includes(lowerKey)
      ) {
        mappedConfigs[identifier] = cfg;
      }
    }
  }
  config.agentConfigs = mappedConfigs;

  let selected = agents;
  if (config.cliAgents && config.cliAgents.length > 0) {
    const filters = config.cliAgents.map((n) => n.toLowerCase());
    selected = agents.filter((agent) =>
      filters.some(
        (f) =>
          agent.getIdentifier() === f ||
          agent.getName().toLowerCase().includes(f),
      ),
    );
    logVerbose(
      `Selected agents via CLI filter: ${selected.map((a) => a.getName()).join(', ')}`,
      verbose,
    );
  } else if (config.defaultAgents && config.defaultAgents.length > 0) {
    const defaults = config.defaultAgents.map((n) => n.toLowerCase());
    selected = agents.filter((agent) => {
      const identifier = agent.getIdentifier();
      const override = config.agentConfigs[identifier]?.enabled;
      if (override !== undefined) {
        return override;
      }
      return defaults.some(
        (d) => identifier === d || agent.getName().toLowerCase().includes(d),
      );
    });
    logVerbose(
      `Selected agents via config default_agents: ${selected.map((a) => a.getName()).join(', ')}`,
      verbose,
    );
  } else {
    selected = agents.filter(
      (agent) => config.agentConfigs[agent.getIdentifier()]?.enabled !== false,
    );
    logVerbose(
      `Selected all enabled agents: ${selected.map((a) => a.getName()).join(', ')}`,
      verbose,
    );
  }

  let totalFilesProcessed = 0;
  let totalFilesRestored = 0;
  let totalFilesRemoved = 0;
  let totalBackupsRemoved = 0;

  for (const agent of selected) {
    const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';
    console.log(`${actionPrefix} Reverting ${agent.getName()}...`);

    const agentConfig = config.agentConfigs[agent.getIdentifier()];
    const outputPaths = getAgentOutputPaths(agent, projectRoot, agentConfig);

    logVerbose(
      `Agent ${agent.getName()} output paths: ${outputPaths.join(', ')}`,
      verbose,
    );

    for (const outputPath of outputPaths) {
      totalFilesProcessed++;

      const restored = await restoreFromBackup(outputPath, verbose, dryRun);
      if (restored) {
        totalFilesRestored++;

        if (!keepBackups) {
          const backupRemoved = await removeBackupFile(
            outputPath,
            verbose,
            dryRun,
          );
          if (backupRemoved) {
            totalBackupsRemoved++;
          }
        }
      } else {
        const removed = await removeGeneratedFile(outputPath, verbose, dryRun);
        if (removed) {
          totalFilesRemoved++;
        }
      }
    }

    const mcpPath = await getNativeMcpPath(agent.getName(), projectRoot);
    if (mcpPath && mcpPath.startsWith(projectRoot)) {
      totalFilesProcessed++;

      if (
        agent.getName() === 'AugmentCode' &&
        mcpPath.endsWith('.vscode/settings.json')
      ) {
        logVerbose(
          `Skipping MCP handling for AugmentCode settings.json - handled separately`,
          verbose,
        );
      } else {
        const mcpRestored = await restoreFromBackup(mcpPath, verbose, dryRun);
        if (mcpRestored) {
          totalFilesRestored++;

          if (!keepBackups) {
            const mcpBackupRemoved = await removeBackupFile(
              mcpPath,
              verbose,
              dryRun,
            );
            if (mcpBackupRemoved) {
              totalBackupsRemoved++;
            }
          }
        } else {
          const mcpRemoved = await removeGeneratedFile(
            mcpPath,
            verbose,
            dryRun,
          );
          if (mcpRemoved) {
            totalFilesRemoved++;
          }
        }
      }
    }
  }

  const gitignoreCleaned =
    !config.cliAgents || config.cliAgents.length === 0
      ? await cleanGitignore(projectRoot, verbose, dryRun)
      : false;

  const additionalFilesRemoved = await removeAdditionalAgentFiles(
    projectRoot,
    verbose,
    dryRun,
  );
  totalFilesRemoved += additionalFilesRemoved;

  const directoriesRemoved = await removeEmptyDirectories(
    projectRoot,
    verbose,
    dryRun,
  );

  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  if (dryRun) {
    console.log(`${actionPrefix} Revert summary (dry run):`);
  } else {
    console.log(`${actionPrefix} Revert completed successfully.`);
  }

  console.log(`  Files processed: ${totalFilesProcessed}`);
  console.log(`  Files restored from backup: ${totalFilesRestored}`);
  console.log(`  Generated files removed: ${totalFilesRemoved}`);
  if (!keepBackups) {
    console.log(`  Backup files removed: ${totalBackupsRemoved}`);
  }
  if (directoriesRemoved > 0) {
    console.log(`  Empty directories removed: ${directoriesRemoved}`);
  }
  if (gitignoreCleaned) {
    console.log(`  .gitignore cleaned: yes`);
  }
}
