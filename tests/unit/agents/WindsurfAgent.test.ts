import { promises as fs } from 'fs';
import * as path from 'path';
import os from 'os';

import { WindsurfAgent } from '../../../src/agents/WindsurfAgent';
import { AgentsMdAgent } from '../../../src/agents/AgentsMdAgent';

describe('WindsurfAgent', () => {
  let tmpDir: string;

  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-windsurf-'));
  });

  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });

  it('extends AgentsMdAgent so it reuses shared AGENTS.md logic', () => {
    const agent = new WindsurfAgent();
    expect(agent instanceof AgentsMdAgent).toBe(true);
  });

  it('exposes the expected identifier and name', () => {
    const agent = new WindsurfAgent();
    expect(agent.getIdentifier()).toBe('windsurf');
    expect(agent.getName()).toBe('Windsurf');
  });

  it('defaults to writing to the shared AGENTS.md at the project root', () => {
    const agent = new WindsurfAgent();
    expect(agent.getDefaultOutputPath(tmpDir)).toBe(
      path.join(tmpDir, 'AGENTS.md'),
    );
  });

  it('delegates to AgentsMdAgent for applyRulerConfig (idempotent write)', async () => {
    const agent = new WindsurfAgent();
    const target = path.join(tmpDir, 'AGENTS.md');

    await agent.applyRulerConfig('# Windsurf rules', tmpDir, null);

    const written = await fs.readFile(target, 'utf8');
    expect(written).toBe('<!-- Generated by Ruler -->\n# Windsurf rules');

    // Second apply should not rewrite or create a new backup when content matches.
    await fs.writeFile(target, written);
    await agent.applyRulerConfig('# Windsurf rules', tmpDir, null);
    const backupExists = await fs
      .access(`${target}.bak`)
      .then(() => true)
      .catch(() => false);
    expect(backupExists).toBe(false);
  });
});
