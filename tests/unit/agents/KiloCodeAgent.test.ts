import { promises as fs } from 'fs';
import * as path from 'path';
import os from 'os';

import { KiloCodeAgent } from '../../../src/agents/KiloCodeAgent';

describe('KiloCodeAgent', () => {
  let tmpDir: string;

  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-kilocode-'));
  });

  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });

  describe('Basic Agent Interface', () => {
    it('returns correct identifier', () => {
      const agent = new KiloCodeAgent();
      expect(agent.getIdentifier()).toBe('kilocode');
    });

    it('returns correct display name', () => {
      const agent = new KiloCodeAgent();
      expect(agent.getName()).toBe('Kilo Code');
    });

    it('returns correct default output path', () => {
      const agent = new KiloCodeAgent();
      const expected = path.join(tmpDir, 'AGENTS.md');
      expect(agent.getDefaultOutputPath(tmpDir)).toBe(expected);
    });
  });

  describe('File Operations', () => {
    it('backs up and writes AGENTS.md', async () => {
      const agent = new KiloCodeAgent();
      const target = path.join(tmpDir, 'AGENTS.md');

      // Create existing file
      await fs.writeFile(target, 'old kilocode rules');

      // Apply new configuration
      await agent.applyRulerConfig('new kilocode rules', tmpDir, null);

      // Verify backup was created
      expect(await fs.readFile(`${target}.bak`, 'utf8')).toBe(
        'old kilocode rules',
      );

      // Verify new content was written
      expect(await fs.readFile(target, 'utf8')).toBe(
        '<!-- Generated by Ruler -->\nnew kilocode rules',
      );
    });

    it('creates AGENTS.md if it does not exist', async () => {
      const agent = new KiloCodeAgent();
      const target = path.join(tmpDir, 'AGENTS.md');

      // Apply configuration without creating directory first
      await agent.applyRulerConfig('kilocode content', tmpDir, null);

      // Verify file was created with correct content
      expect(await fs.readFile(target, 'utf8')).toBe(
        '<!-- Generated by Ruler -->\nkilocode content',
      );
    });

    it('uses custom outputPath when provided', async () => {
      const agent = new KiloCodeAgent();
      const custom = path.join(tmpDir, 'custom_kilocode.md');
      await fs.mkdir(path.dirname(custom), { recursive: true });

      await agent.applyRulerConfig('custom kilocode data', tmpDir, null, {
        outputPath: custom,
      });

      expect(await fs.readFile(custom, 'utf8')).toBe(
        '<!-- Generated by Ruler -->\ncustom kilocode data',
      );
    });
  });

  describe('Configuration Overrides', () => {
    it('respects custom output path in agent config', async () => {
      const agent = new KiloCodeAgent();
      const customPath = path.join(tmpDir, 'custom', 'kilocode_rules.md');

      await agent.applyRulerConfig('custom path content', tmpDir, null, {
        outputPath: customPath,
      });

      expect(await fs.readFile(customPath, 'utf8')).toBe(
        '<!-- Generated by Ruler -->\ncustom path content',
      );
    });

    it('returns correct MCP server key', () => {
      const agent = new KiloCodeAgent();
      expect(agent.getMcpServerKey()).toBe('mcpServers');
    });
  });

  describe('Native Skills Support', () => {
    it('supports native skills', () => {
      const agent = new KiloCodeAgent();
      expect(agent.supportsNativeSkills()).toBe(true);
    });
  });
});
