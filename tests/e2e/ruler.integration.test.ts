import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { setupTestProject, teardownTestProject, runRulerWithInheritedStdio } from '../harness';

describe('Comprehensive Integration Test: ruler init â†’ setup â†’ apply â†’ verify', () => {
  let testProject: { projectRoot: string };

  beforeAll(async () => {
    testProject = await setupTestProject();
  });

  afterAll(async () => {
    await teardownTestProject(testProject.projectRoot);
  });

  it('executes complete CLI workflow and inspects all generated files', async () => {
    const { projectRoot } = testProject;
    
    console.log('=== COMPREHENSIVE INTEGRATION TEST ===');
    console.log(`Test project directory: ${projectRoot}`);

    // Step 1: Run ruler init
    console.log('\n1. Running ruler init...');
    runRulerWithInheritedStdio('init', projectRoot);

    // Verify init created the expected files
    const rulerDir = path.join(projectRoot, '.ruler');
    const initAgentsFile = path.join(rulerDir, 'AGENTS.md');
    const initTomlFile = path.join(rulerDir, 'ruler.toml');

    await expect(fs.stat(rulerDir)).resolves.toBeDefined();
    await expect(fs.stat(initAgentsFile)).resolves.toBeDefined();
    await expect(fs.stat(initTomlFile)).resolves.toBeDefined();

    console.log('âœ“ ruler init completed successfully');

    // Step 2: Create custom ruler.toml with 2 MCP servers (stdio and remote)
    console.log('\n2. Creating custom ruler.toml with MCP servers...');
    const customTomlContent = `# Ruler Configuration File
# Generated by comprehensive integration test

# Default agents to apply rules to - comprehensive list for testing
defaultAgents = ["copilot", "claude", "cursor", "opencode", "gemini-cli", "codex", "zed", "augmentcode", "qwen", "aider", "openhands", "kilocode", "windsurf", "cline", "goose", "crush", "jules", "junie"]

# Global MCP behavior
[mcp]
enabled = true
merge_strategy = "merge"

# --- MCP Servers ---

# Local/stdio MCP server example
[mcp_servers.filesystem_server]
command = "npx"
args = ["-y", "@modelcontextprotocol/server-filesystem", "${projectRoot}"]

[mcp_servers.filesystem_server.env]
DEBUG = "1"
PROJECT_ROOT = "${projectRoot}"

# Remote MCP server example  
[mcp_servers.remote_api]
url = "https://api.example.com/mcp"

[mcp_servers.remote_api.headers]
Authorization = "Bearer test-token-12345"
"X-API-Version" = "v1"
"Content-Type" = "application/json"

# Agent-specific configuration - enable MCP for key agents
[agents.cursor.mcp]
enabled = true
merge_strategy = "merge"

[agents.copilot.mcp]
enabled = true
merge_strategy = "merge"

[agents.opencode.mcp]
enabled = true
merge_strategy = "merge"

[agents.gemini-cli.mcp]
enabled = true
merge_strategy = "merge"

[agents.codex.mcp]
enabled = true
merge_strategy = "merge"

[agents.zed.mcp]
enabled = true
merge_strategy = "merge"

[agents.augmentcode.mcp]
enabled = true
merge_strategy = "merge"

[agents.qwen.mcp]
enabled = true
merge_strategy = "merge"

[agents.aider.mcp]
enabled = true
merge_strategy = "merge"

[agents.kilocode.mcp]
enabled = true
merge_strategy = "merge"

[agents.claude]
enabled = true
output_path = "CLAUDE.md"

[gitignore]
enabled = true
`;

    await fs.writeFile(initTomlFile, customTomlContent);
    console.log('âœ“ Custom ruler.toml created with stdio and remote MCP servers');

    // Step 3: Create custom AGENTS.md with sample instructions
    console.log('\n3. Creating custom AGENTS.md with sample instructions...');
    const customAgentsContent = `# AGENTS.md
Integration Test Sample Instructions

## General Guidelines

You are an AI coding assistant helping with software development. Follow these guidelines:

1. **Code Quality**: Write clean, readable, and maintainable code
2. **Testing**: Include comprehensive tests for new functionality
3. **Documentation**: Document complex logic and public APIs
4. **Performance**: Consider performance implications of your suggestions

## Language-Specific Rules

### TypeScript/JavaScript
- Use TypeScript for type safety
- Prefer async/await over Promise chains
- Use meaningful variable and function names
- Follow ESLint and Prettier configurations

### Testing Guidelines  
- Write unit tests for all public functions
- Use describe/it structure for test organization
- Mock external dependencies appropriately
- Aim for high test coverage

## Project Context

This is a CLI tool called "Ruler" that helps manage AI coding assistant configurations across different tools and platforms.

## Integration Test Marker
This content was generated by the comprehensive integration test.
`;

    await fs.writeFile(initAgentsFile, customAgentsContent);
    console.log('âœ“ Custom AGENTS.md created with sample instructions');

    // Step 4: Create additional markdown file for concatenation testing
    console.log('\n4. Creating additional markdown file for concatenation...');
    const extraMdFile = path.join(rulerDir, 'extra-rules.md');
    const extraMdContent = `# Extra Rules for Integration Testing

## Additional Guidelines

These are supplementary rules that should be concatenated with the main AGENTS.md file.

### Code Review Standards
- Review for security vulnerabilities
- Check for proper error handling
- Verify input validation
- Ensure proper logging

### Performance Considerations  
- Optimize database queries
- Minimize network calls
- Use caching where appropriate
- Profile memory usage

## Integration Test Verification
This content should appear in concatenated agent files after running ruler apply.
File: extra-rules.md
`;

    await fs.writeFile(extraMdFile, extraMdContent);
    console.log('âœ“ Additional markdown file created for concatenation testing');

    // Step 5: Run ruler apply
    console.log('\n5. Running ruler apply...');
    runRulerWithInheritedStdio('apply', projectRoot);
    console.log('âœ“ ruler apply completed successfully');

    // Step 6: Inspect all generated files
    console.log('\n6. Inspecting and verifying all generated files...');

    // List of expected generated files - comprehensive list for all agents
    const expectedFiles = [
      // Markdown rule files
      'AGENTS.md', // Root level concatenated file
      'CLAUDE.md', // Claude-specific file
      'CRUSH.md', // Crush-specific file
      
      // GitHub Copilot (writes to both AGENTS.md and legacy location)
      '.github/copilot-instructions.md', // Copilot legacy instructions for VS Code extension
      '.vscode/mcp.json', // Copilot MCP config

      // Cursor (now uses AGENTS.md)
      '.cursor/mcp.json', // Cursor MCP config
      
      // OpenCode
      'opencode.json',
      
      // Gemini CLI
      '.gemini/settings.json',
      
      // Codex CLI (OpenAI)
      '.codex/config.toml',
      
      // Zed
      '.zed/settings.json',
      
      // AugmentCode
      '.augment/rules/ruler_augment_instructions.md',
      '.vscode/settings.json', // AugmentCode also uses VSCode settings
      
      // Qwen Code
      '.qwen/settings.json',
      
      // Aider
      '.aider.conf.yml',
      '.mcp.json', // Aider MCP config
      
      // OpenHands
      'config.toml',
      '.openhands/microagents/repo.md',
      
      // Kilo Code
      '.kilocode/rules/ruler_kilocode_instructions.md',
      '.kilocode/mcp.json',
      
      // Windsurf - now uses AGENTS.md (no separate file)
      '.windsurf/mcp_config.json', // MCP config still created
      
      // Cline
      '.clinerules',
      
      // Goose
      '.goosehints',
      
      // Junie
      '.junie/guidelines.md',
      
      // Shared
      '.gitignore', // Updated gitignore
    ];

    const generatedFiles: string[] = [];
    const fileContents: Record<string, string> = {};

    // Check each expected file
    for (const expectedFile of expectedFiles) {
      const filePath = path.join(projectRoot, expectedFile);
      try {
        const stat = await fs.stat(filePath);
        if (stat.isFile()) {
          generatedFiles.push(expectedFile);
          const content = await fs.readFile(filePath, 'utf8');
          fileContents[expectedFile] = content;
          console.log(`âœ“ Found generated file: ${expectedFile} (${content.length} characters)`);
        }
      } catch (error) {
        console.log(`âœ— Expected file not found: ${expectedFile}`);
      }
    }

    // Step 7: Verify file contents contain expected elements
    console.log('\n7. Verifying file contents...');

    // Verify markdown rule files contain concatenated content
    const markdownRuleFiles = ['AGENTS.md', 'CLAUDE.md', 'CRUSH.md'];
    for (const file of markdownRuleFiles) {
      if (fileContents[file]) {
        expect(fileContents[file]).toContain('Integration Test Sample Instructions');
        expect(fileContents[file]).toContain('Extra Rules for Integration Testing');
        console.log(`âœ“ ${file} contains expected concatenated content`);
      }
    }

    // Verify JSON configuration files
    const jsonConfigFiles = [
      { path: 'opencode.json', expectedSchema: 'https://opencode.ai/config.json', mcpKey: 'mcp' },
      { path: '.gemini/settings.json', expectedKey: 'contextFileName', expectedValue: 'AGENTS.md' },
      { path: '.qwen/settings.json', expectedKey: 'contextFileName', expectedValue: 'AGENTS.md' },
      { path: '.zed/settings.json', mcpKey: 'context_servers' },
      { path: '.vscode/settings.json', mcpKey: 'mcpServers' }, // AugmentCode
      { path: '.cursor/mcp.json', mcpKey: 'mcpServers' },
      { path: '.vscode/mcp.json', mcpKey: 'mcpServers' }, // Copilot
      { path: '.kilocode/mcp.json', mcpKey: 'mcpServers' },
      { path: '.mcp.json', mcpKey: 'mcpServers' }, // Aider
    ];

    for (const { path, expectedSchema, expectedKey, expectedValue, mcpKey } of jsonConfigFiles) {
      if (fileContents[path]) {
        try {
          const config = JSON.parse(fileContents[path]);
          
          // Check for expected schema
          if (expectedSchema) {
            expect(config.$schema).toBe(expectedSchema);
            console.log(`âœ“ ${path} has correct schema: ${expectedSchema}`);
          }
          
          // Check for expected key-value pairs
          if (expectedKey && expectedValue) {
            expect(config[expectedKey]).toBe(expectedValue);
            console.log(`âœ“ ${path} has correct ${expectedKey}: ${expectedValue}`);
          }
          
          // Check for MCP server configurations
          if (mcpKey && config[mcpKey]) {
            const mcpServers = config[mcpKey];
            expect(typeof mcpServers).toBe('object');
            
            // Should contain our configured MCP servers
            if (mcpServers.filesystem_server) {
              console.log(`âœ“ ${path} contains filesystem_server MCP configuration`);
            }
            if (mcpServers.remote_api) {
              console.log(`âœ“ ${path} contains remote_api MCP configuration`);
            }
            
            console.log(`âœ“ ${path} has valid MCP configuration with ${Object.keys(mcpServers).length} server(s)`);
          }
          
        } catch (error) {
          console.log(`âš  ${path} is not valid JSON or has unexpected structure: ${error}`);
        }
      }
    }

    // Verify TOML configuration files
    const tomlConfigFiles = [
      { path: '.codex/config.toml', mcpKey: 'mcp_servers' },
      { path: 'config.toml', sectionKey: 'microagent' },
    ];

    for (const { path, mcpKey, sectionKey } of tomlConfigFiles) {
      if (fileContents[path]) {
        try {
          // Basic TOML validation - just check it contains expected sections
          const content = fileContents[path];
          
          if (mcpKey) {
            expect(content).toMatch(new RegExp(`\\[${mcpKey}\\.|${mcpKey}\\s*=`));
            console.log(`âœ“ ${path} contains ${mcpKey} configuration`);
          }
          
          if (sectionKey) {
            expect(content).toContain(sectionKey);
            console.log(`âœ“ ${path} contains ${sectionKey} section`);
          }
          
        } catch (error) {
          console.log(`âš  ${path} has unexpected TOML structure: ${error}`);
        }
      }
    }

    // Verify YAML configuration files
    if (fileContents['.aider.conf.yml']) {
      // Aider config should be valid YAML
      const content = fileContents['.aider.conf.yml'];
      expect(content.length).toBeGreaterThan(0);
      console.log('âœ“ Aider YAML configuration exists and has content');
    }

    // Verify other instruction files
    const otherInstructionFiles = [
      '.augment/rules/ruler_augment_instructions.md',
      '.openhands/microagents/repo.md',
      '.kilocode/rules/ruler_kilocode_instructions.md',
      // Windsurf now uses AGENTS.md (checked above in markdownRuleFiles)
      '.clinerules',
      '.goosehints',
      '.junie/guidelines.md',
    ];

    for (const file of otherInstructionFiles) {
      if (fileContents[file]) {
        expect(fileContents[file]).toContain('Integration Test Sample Instructions');
        console.log(`âœ“ ${file} contains expected content`);
      }
    }

    // Verify GitHub Copilot dual-file support
    if (fileContents['AGENTS.md'] && fileContents['.github/copilot-instructions.md']) {
      expect(fileContents['AGENTS.md']).toBe(fileContents['.github/copilot-instructions.md']);
      console.log('âœ“ GitHub Copilot: AGENTS.md and .github/copilot-instructions.md have identical content');
      expect(fileContents['.github/copilot-instructions.md']).toContain('Integration Test Sample Instructions');
      console.log('âœ“ GitHub Copilot legacy file contains expected content');
    }

    // Verify .gitignore contains ruler entries
    if (fileContents['.gitignore']) {
      expect(fileContents['.gitignore']).toContain('# START Ruler Generated Files');
      expect(fileContents['.gitignore']).toContain('# END Ruler Generated Files');
      // Should contain entries for some of the files we're generating
      expect(fileContents['.gitignore']).toContain('opencode.json');
      expect(fileContents['.gitignore']).toContain('.gemini/settings.json');
      // Note: .codex/config.toml might not be in gitignore if agent doesn't register it
      console.log('âœ“ .gitignore contains comprehensive Ruler-generated entries');
    }

    // Step 8: Output all generated file contents for manual inspection
    console.log('\n8. OUTPUTTING ALL GENERATED FILE CONTENTS:\n');
    console.log('='.repeat(80));

    for (const [fileName, content] of Object.entries(fileContents)) {
      console.log(`\nðŸ“„ FILE: ${fileName}`);
      console.log('â”€'.repeat(60));
      console.log(content);
      console.log('â”€'.repeat(60));
    }

    // Step 9: Verify MCP server configurations across all agents
    console.log('\n9. Verifying MCP server configurations across all agents...');

    // List of MCP config files and their expected keys
    const mcpConfigs = [
      { path: '.cursor/mcp.json', key: 'mcpServers', name: 'Cursor' },
      { path: '.vscode/mcp.json', key: 'mcpServers', name: 'GitHub Copilot' },
      { path: '.vscode/settings.json', key: 'mcpServers', name: 'AugmentCode' },
      { path: '.gemini/settings.json', key: 'mcpServers', name: 'Gemini CLI' },
      { path: '.qwen/settings.json', key: 'mcpServers', name: 'Qwen Code' },
      { path: '.zed/settings.json', key: 'context_servers', name: 'Zed' },
      { path: '.kilocode/mcp.json', key: 'mcpServers', name: 'Kilo Code' },
      { path: '.mcp.json', key: 'mcpServers', name: 'Aider' },
      { path: 'opencode.json', key: 'mcp', name: 'OpenCode' },
    ];

    for (const { path: configPath, key, name } of mcpConfigs) {
      try {
        const stat = await fs.stat(path.join(projectRoot, configPath));
        if (stat.isFile()) {
          const content = await fs.readFile(path.join(projectRoot, configPath), 'utf8');
          const config = JSON.parse(content);
          
          if (config[key]) {
            const servers = config[key];
            
            // Verify our configured MCP servers are present
            let foundServers = [];
            if (servers.filesystem_server || servers['filesystem_server']) {
              foundServers.push('filesystem_server');
            }
            if (servers.remote_api || servers['remote_api']) {
              foundServers.push('remote_api');
            }
            
            if (foundServers.length > 0) {
              console.log(`âœ“ ${name} MCP configuration contains: ${foundServers.join(', ')}`);
              
              // Detailed verification for specific agents
              if (configPath === 'opencode.json') {
                // OpenCode has a special structure
                if (servers.filesystem_server) {
                  expect(servers.filesystem_server.type).toBe('local');
                  expect(Array.isArray(servers.filesystem_server.command)).toBe(true);
                }
              } else if (configPath === '.zed/settings.json') {
                // Zed uses context_servers with source: "custom"
                if (servers.filesystem_server) {
                  expect(servers.filesystem_server.source).toBe('custom');
                }
              } else {
                // Most other agents use standard MCP format
                if (servers.filesystem_server) {
                  expect(servers.filesystem_server.command).toBe('npx');
                  expect(Array.isArray(servers.filesystem_server.args)).toBe(true);
                }
              }
              
              // Display the full config for inspection
              console.log(`\nðŸ“„ ${name.toUpperCase()} MCP CONFIG (${configPath}):`);
              console.log('â”€'.repeat(50));
              console.log(JSON.stringify(config[key], null, 2));
              console.log('â”€'.repeat(50));
            } else {
              console.log(`â„¹ ${name} MCP configuration found but no test servers configured`);
            }
          } else {
            console.log(`â„¹ ${name} config file found but no MCP section with key '${key}'`);
          }
        }
      } catch (error) {
        console.log(`â„¹ ${name} MCP file not found or not accessible: ${configPath}`);
      }
    }

    // Special verification for Codex CLI TOML config
    const codexConfigPath = path.join(projectRoot, '.codex/config.toml');
    try {
      const stat = await fs.stat(codexConfigPath);
      if (stat.isFile()) {
        const content = await fs.readFile(codexConfigPath, 'utf8');
        
        // Check if it contains our MCP servers
        if (content.includes('[mcp_servers.filesystem_server]') || content.includes('[mcp_servers.remote_api]')) {
          console.log('âœ“ Codex CLI TOML configuration contains MCP servers');
          console.log('\nðŸ“„ CODEX CLI CONFIG (.codex/config.toml):');
          console.log('â”€'.repeat(50));
          console.log(content);
          console.log('â”€'.repeat(50));
        }
      }
    } catch (error) {
      console.log('â„¹ Codex CLI TOML config not found or not accessible');
    }

    // Special verification for OpenHands TOML config
    const openhandsConfigPath = path.join(projectRoot, 'config.toml');
    try {
      const stat = await fs.stat(openhandsConfigPath);
      if (stat.isFile()) {
        const content = await fs.readFile(openhandsConfigPath, 'utf8');
        console.log('âœ“ OpenHands TOML configuration generated');
        console.log('\nðŸ“„ OPENHANDS CONFIG (config.toml):');
        console.log('â”€'.repeat(50));
        console.log(content);
        console.log('â”€'.repeat(50));
      }
    } catch (error) {
      console.log('â„¹ OpenHands config not found or not accessible');
    }

    // Final verification - should have generated significantly more files than the basic test
    expect(generatedFiles.length).toBeGreaterThan(10);
    console.log(`\nâœ… COMPREHENSIVE INTEGRATION TEST COMPLETED SUCCESSFULLY!`);
    console.log(`Generated ${generatedFiles.length} files total`);
    console.log(`Files generated: ${generatedFiles.slice(0, 10).join(', ')}${generatedFiles.length > 10 ? `, and ${generatedFiles.length - 10} more...` : ''}`);
    console.log('='.repeat(80));
  }, 60000); // 60 second timeout for the comprehensive test
});