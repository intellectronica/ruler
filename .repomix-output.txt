This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
    release.yml
.specstory/
  history/
  .gitignore
src/
  agents/
    AiderAgent.ts
    ClaudeAgent.ts
    ClineAgent.ts
    CodexCliAgent.ts
    CopilotAgent.ts
    CursorAgent.ts
    FirebaseAgent.ts
    GeminiCliAgent.ts
    IAgent.ts
    OpenHandsAgent.ts
    WindsurfAgent.ts
  cli/
    commands.ts
    index.ts
  core/
    ConfigLoader.ts
    FileSystemUtils.ts
    GitignoreUtils.ts
    RuleProcessor.ts
  mcp/
    merge.ts
    propagateOpenHandsMcp.ts
    validate.ts
  paths/
    mcp.ts
  constants.ts
  lib.ts
  types.ts
test-qa/
  .ruler/
    instructions.md
    mcp.json
    ruler.toml
  .gitignore
  claude_desktop_config.json
tests/
  e2e/
    ruler.init.test.ts
    ruler.test.ts
  integration/
    lowercase-identifiers.test.ts
  unit/
    agents/
      AgentAdapters.test.ts
      FirebaseAgent.test.ts
      GeminiCliAgent.test.ts
      LowercaseIdentifiers.test.ts
      OpenHandsAgent.test.ts
    core/
      ConfigLoader.test.ts
      constants.test.ts
      FileSystemUtils.test.js
      FileSystemUtils.test.ts
      GitignoreUtils.test.ts
      LowercaseConfig.test.ts
      RuleProcessor.test.js
      RuleProcessor.test.ts
    mcp/
      OpenHandsMcp.test.ts
  agent-specific-disable.test.ts
  apply-mcp.disable.toml.test.ts
  apply-mcp.merge.test.ts
  apply-mcp.overwrite.test.ts
  cli-no-mcp.test.ts
  mcp-key-overwrite.test.ts
  mcp-key-per-agent.test.ts
.cursorindexingignore
.eslintignore
.gitignore
.prettierignore
jest.config.js
LICENSE
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/ci.yml">
name: CI
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18.x, 20.x]
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      - run: npm ci
      - run: npm run lint
      - run: npm test
      - run: npm run build
</file>

<file path=".github/workflows/release.yml">
name: Release
on:
  release:
    types: [created]
jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18.x'
          registry-url: 'https://registry.npmjs.org/'
      - run: npm ci
      - run: npm run build
      - run: npm publish --access public
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
</file>

<file path=".specstory/.gitignore">
# SpecStory explanation file
/.what-is-this.md
</file>

<file path="src/cli/index.ts">
#!/usr/bin/env node
import { run } from './commands';
run();
</file>

<file path="src/core/ConfigLoader.ts">
import { promises as fs } from 'fs';
import * as path from 'path';
import TOML from '@iarna/toml';
import { z } from 'zod';
import { McpConfig, GlobalMcpConfig, GitignoreConfig } from '../types';
import { createRulerError } from '../constants';
interface ErrnoException extends Error {
  code?: string;
}
const mcpConfigSchema = z
  .object({
    enabled: z.boolean().optional(),
    merge_strategy: z.enum(['merge', 'overwrite']).optional(),
  })
  .optional();
const agentConfigSchema = z
  .object({
    enabled: z.boolean().optional(),
    output_path: z.string().optional(),
    output_path_instructions: z.string().optional(),
    output_path_config: z.string().optional(),
    mcp: mcpConfigSchema,
  })
  .optional();
const rulerConfigSchema = z.object({
  default_agents: z.array(z.string()).optional(),
  agents: z.record(z.string(), agentConfigSchema).optional(),
  mcp: z
    .object({
      enabled: z.boolean().optional(),
      merge_strategy: z.enum(['merge', 'overwrite']).optional(),
    })
    .optional(),
  gitignore: z
    .object({
      enabled: z.boolean().optional(),
    })
    .optional(),
});
/**
 * Configuration for a specific agent as defined in ruler.toml.
 */
export interface IAgentConfig {
  enabled?: boolean;
  outputPath?: string;
  outputPathInstructions?: string;
  outputPathConfig?: string;
  /** MCP propagation config for this agent. */
  mcp?: McpConfig;
}
/**
 * Parsed ruler configuration values.
 */
export interface LoadedConfig {
  /** Agents to run by default, as specified by default_agents. */
  defaultAgents?: string[];
  /** Per-agent configuration overrides. */
  agentConfigs: Record<string, IAgentConfig>;
  /** Command-line agent filters (--agents), if provided. */
  cliAgents?: string[];
  /** Global MCP servers configuration section. */
  mcp?: GlobalMcpConfig;
  /** Gitignore configuration section. */
  gitignore?: GitignoreConfig;
}
/**
 * Options for loading the ruler configuration.
 */
export interface ConfigOptions {
  projectRoot: string;
  /** Path to a custom TOML config file. */
  configPath?: string;
  /** CLI filters from --agents option. */
  cliAgents?: string[];
}
/**
 * Loads and parses the ruler TOML configuration file, applying defaults.
 * If the file is missing or invalid, returns empty/default config.
 */
export async function loadConfig(
  options: ConfigOptions,
): Promise<LoadedConfig> {
  const { projectRoot, configPath, cliAgents } = options;
  const configFile = configPath
    ? path.resolve(configPath)
    : path.join(projectRoot, '.ruler', 'ruler.toml');
  let raw: Record<string, unknown> = {};
  try {
    const text = await fs.readFile(configFile, 'utf8');
    raw = text.trim() ? TOML.parse(text) : {};
    // Validate the configuration with zod
    const validationResult = rulerConfigSchema.safeParse(raw);
    if (!validationResult.success) {
      throw createRulerError(
        'Invalid configuration file format',
        `File: ${configFile}, Errors: ${validationResult.error.issues.map((i) => `${i.path.join('.')}: ${i.message}`).join(', ')}`,
      );
    }
  } catch (err) {
    if (err instanceof Error && (err as ErrnoException).code !== 'ENOENT') {
      if (err.message.includes('[RulerError]')) {
        throw err; // Re-throw validation errors
      }
      console.warn(
        `[ruler] Warning: could not read config file at ${configFile}: ${err.message}`,
      );
    }
    raw = {};
  }
  const defaultAgents = Array.isArray(raw.default_agents)
    ? raw.default_agents.map((a) => String(a))
    : undefined;
  const agentsSection =
    raw.agents && typeof raw.agents === 'object' && !Array.isArray(raw.agents)
      ? (raw.agents as Record<string, unknown>)
      : {};
  const agentConfigs: Record<string, IAgentConfig> = {};
  for (const [name, section] of Object.entries(agentsSection)) {
    if (section && typeof section === 'object') {
      const sectionObj = section as Record<string, unknown>;
      const cfg: IAgentConfig = {};
      if (typeof sectionObj.enabled === 'boolean') {
        cfg.enabled = sectionObj.enabled;
      }
      if (typeof sectionObj.output_path === 'string') {
        cfg.outputPath = path.resolve(projectRoot, sectionObj.output_path);
      }
      if (typeof sectionObj.output_path_instructions === 'string') {
        cfg.outputPathInstructions = path.resolve(
          projectRoot,
          sectionObj.output_path_instructions,
        );
      }
      if (typeof sectionObj.output_path_config === 'string') {
        cfg.outputPathConfig = path.resolve(
          projectRoot,
          sectionObj.output_path_config,
        );
      }
      if (sectionObj.mcp && typeof sectionObj.mcp === 'object') {
        const m = sectionObj.mcp as Record<string, unknown>;
        const mcpCfg: McpConfig = {};
        if (typeof m.enabled === 'boolean') {
          mcpCfg.enabled = m.enabled;
        }
        if (typeof m.merge_strategy === 'string') {
          const ms = m.merge_strategy;
          if (ms === 'merge' || ms === 'overwrite') {
            mcpCfg.strategy = ms;
          }
        }
        cfg.mcp = mcpCfg;
      }
      agentConfigs[name] = cfg;
    }
  }
  const rawMcpSection =
    raw.mcp && typeof raw.mcp === 'object' && !Array.isArray(raw.mcp)
      ? (raw.mcp as Record<string, unknown>)
      : {};
  const globalMcpConfig: GlobalMcpConfig = {};
  if (typeof rawMcpSection.enabled === 'boolean') {
    globalMcpConfig.enabled = rawMcpSection.enabled;
  }
  if (typeof rawMcpSection.merge_strategy === 'string') {
    const strat = rawMcpSection.merge_strategy;
    if (strat === 'merge' || strat === 'overwrite') {
      globalMcpConfig.strategy = strat;
    }
  }
  const rawGitignoreSection =
    raw.gitignore &&
    typeof raw.gitignore === 'object' &&
    !Array.isArray(raw.gitignore)
      ? (raw.gitignore as Record<string, unknown>)
      : {};
  const gitignoreConfig: GitignoreConfig = {};
  if (typeof rawGitignoreSection.enabled === 'boolean') {
    gitignoreConfig.enabled = rawGitignoreSection.enabled;
  }
  return {
    defaultAgents,
    agentConfigs,
    cliAgents,
    mcp: globalMcpConfig,
    gitignore: gitignoreConfig,
  };
}
</file>

<file path="src/core/FileSystemUtils.ts">
import { promises as fs } from 'fs';
import * as path from 'path';
/**
 * Searches upwards from startPath to find a directory named .ruler.
 * Returns the path to the .ruler directory, or null if not found.
 */
export async function findRulerDir(startPath: string): Promise<string | null> {
  let current = startPath;
  while (current) {
    const candidate = path.join(current, '.ruler');
    try {
      const stat = await fs.stat(candidate);
      if (stat.isDirectory()) {
        return candidate;
      }
    } catch {
      // ignore errors when checking for .ruler directory
    }
    const parent = path.dirname(current);
    if (parent === current) {
      break;
    }
    current = parent;
  }
  return null;
}
/**
 * Recursively reads all Markdown (.md) files in rulerDir, returning their paths and contents.
 * Files are sorted alphabetically by path.
 */
export async function readMarkdownFiles(
  rulerDir: string,
): Promise<{ path: string; content: string }[]> {
  const results: { path: string; content: string }[] = [];
  async function walk(dir: string) {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        await walk(fullPath);
      } else if (entry.isFile() && entry.name.endsWith('.md')) {
        const content = await fs.readFile(fullPath, 'utf8');
        results.push({ path: fullPath, content });
      }
    }
  }
  await walk(rulerDir);
  results.sort((a, b) => a.path.localeCompare(b.path));
  return results;
}
/**
 * Writes content to filePath, creating parent directories if necessary.
 */
export async function writeGeneratedFile(
  filePath: string,
  content: string,
): Promise<void> {
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, content, 'utf8');
}
/**
 * Creates a backup of the given filePath by copying it to filePath.bak if it exists.
 */
export async function backupFile(filePath: string): Promise<void> {
  try {
    await fs.access(filePath);
    await fs.copyFile(filePath, `${filePath}.bak`);
  } catch {
    // ignore if file does not exist
  }
}
/**
 * Ensures that the given directory exists by creating it recursively.
 */
export async function ensureDirExists(dirPath: string): Promise<void> {
  await fs.mkdir(dirPath, { recursive: true });
}
</file>

<file path="src/core/GitignoreUtils.ts">
import { promises as fs } from 'fs';
import * as path from 'path';
const RULER_START_MARKER = '# START Ruler Generated Files';
const RULER_END_MARKER = '# END Ruler Generated Files';
/**
 * Updates the .gitignore file in the project root with paths in a managed Ruler block.
 * Creates the file if it doesn't exist, and creates or updates the Ruler-managed block.
 *
 * @param projectRoot The project root directory (where .gitignore should be located)
 * @param paths Array of file paths to add to .gitignore (can be absolute or relative)
 */
export async function updateGitignore(
  projectRoot: string,
  paths: string[],
): Promise<void> {
  const gitignorePath = path.join(projectRoot, '.gitignore');
  // Read existing .gitignore or start with empty content
  let existingContent = '';
  try {
    existingContent = await fs.readFile(gitignorePath, 'utf8');
  } catch (err) {
    if ((err as NodeJS.ErrnoException).code !== 'ENOENT') {
      throw err;
    }
  }
  // Convert paths to relative POSIX format
  const relativePaths = paths.map((p) => {
    let relative: string;
    if (path.isAbsolute(p)) {
      relative = path.relative(projectRoot, p);
    } else {
      // Handle relative paths that might include the project root prefix
      const normalizedProjectRoot = path.normalize(projectRoot);
      const normalizedPath = path.normalize(p);
      // Get the basename of the project root to match against path prefixes
      const projectBasename = path.basename(normalizedProjectRoot);
      // If the path starts with the project basename, remove it
      if (normalizedPath.startsWith(projectBasename + path.sep)) {
        relative = normalizedPath.substring(projectBasename.length + 1);
      } else {
        relative = normalizedPath;
      }
    }
    return relative.replace(/\\/g, '/'); // Convert to POSIX format
  });
  // Get all existing paths from .gitignore (excluding Ruler block)
  const existingPaths = getExistingPathsExcludingRulerBlock(existingContent);
  // Filter out paths that already exist outside the Ruler block
  const newPaths = relativePaths.filter((p) => !existingPaths.includes(p));
  // The Ruler block should contain only the new paths (replacement behavior)
  const allRulerPaths = [...new Set(newPaths)].sort();
  // Create new content
  const newContent = updateGitignoreContent(existingContent, allRulerPaths);
  // Write the updated content
  await fs.writeFile(gitignorePath, newContent);
}
/**
 * Gets all paths from .gitignore content excluding those in the Ruler block.
 */
function getExistingPathsExcludingRulerBlock(content: string): string[] {
  const lines = content.split('\n');
  const paths: string[] = [];
  let inRulerBlock = false;
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed === RULER_START_MARKER) {
      inRulerBlock = true;
      continue;
    }
    if (trimmed === RULER_END_MARKER) {
      inRulerBlock = false;
      continue;
    }
    if (!inRulerBlock && trimmed && !trimmed.startsWith('#')) {
      paths.push(trimmed);
    }
  }
  return paths;
}
/**
 * Updates the .gitignore content by replacing or adding the Ruler block.
 */
function updateGitignoreContent(
  existingContent: string,
  rulerPaths: string[],
): string {
  const lines = existingContent.split('\n');
  const newLines: string[] = [];
  let inFirstRulerBlock = false;
  let hasRulerBlock = false;
  let processedFirstBlock = false;
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed === RULER_START_MARKER && !processedFirstBlock) {
      inFirstRulerBlock = true;
      hasRulerBlock = true;
      newLines.push(line);
      // Add the new Ruler paths
      rulerPaths.forEach((p) => newLines.push(p));
      continue;
    }
    if (trimmed === RULER_END_MARKER && inFirstRulerBlock) {
      inFirstRulerBlock = false;
      processedFirstBlock = true;
      newLines.push(line);
      continue;
    }
    if (!inFirstRulerBlock) {
      newLines.push(line);
    }
    // Skip lines that are in the first Ruler block (they get replaced)
  }
  // If no Ruler block exists, add one at the end
  if (!hasRulerBlock) {
    // Add blank line if content exists and doesn't end with blank line
    if (existingContent.trim() && !existingContent.endsWith('\n\n')) {
      newLines.push('');
    }
    newLines.push(RULER_START_MARKER);
    rulerPaths.forEach((p) => newLines.push(p));
    newLines.push(RULER_END_MARKER);
  }
  // Ensure file ends with a newline
  let result = newLines.join('\n');
  if (!result.endsWith('\n')) {
    result += '\n';
  }
  return result;
}
</file>

<file path="src/core/RuleProcessor.ts">
import * as path from 'path';
/**
 * Concatenates markdown rule files into a single string,
 * marking each section with its source filename.
 */
export function concatenateRules(
  files: { path: string; content: string }[],
): string {
  const sections = files.map(({ path: filePath, content }) => {
    const rel = path.relative(process.cwd(), filePath);
    return ['---', `Source: ${rel}`, '---', content.trim(), ''].join('\n');
  });
  return sections.join('\n');
}
</file>

<file path="src/mcp/merge.ts">
import { McpStrategy } from '../types';
/**
 * Merge native and incoming MCP server configurations according to strategy.
 * @param base Existing native MCP config object.
 * @param incoming Ruler MCP config object.
 * @param strategy Merge strategy: 'merge' to union servers, 'overwrite' to replace.
 * @param serverKey The key to use for servers in the output (e.g., 'servers' for Copilot, 'mcpServers' for others).
 * @returns Merged MCP config object.
 */
export function mergeMcp(
  base: Record<string, unknown>,
  incoming: Record<string, unknown>,
  strategy: McpStrategy,
  serverKey: string,
): Record<string, unknown> {
  if (strategy === 'overwrite') {
    // Ensure the incoming object uses the correct server key.
    const incomingServers =
      (incoming.mcpServers as Record<string, unknown>) || {};
    return {
      [serverKey]: incomingServers,
    };
  }
  const baseServers =
    (base[serverKey] as Record<string, unknown>) ||
    (base.mcpServers as Record<string, unknown>) ||
    {}; // Handle legacy key in existing files
  const incomingServers =
    (incoming.mcpServers as Record<string, unknown>) || {};
  const mergedServers = { ...baseServers, ...incomingServers };
  const newBase = { ...base };
  delete newBase.mcpServers; // Remove old key if present
  return {
    ...newBase,
    [serverKey]: mergedServers,
  } as Record<string, unknown>;
}
</file>

<file path="src/mcp/propagateOpenHandsMcp.ts">
import * as fs from 'fs/promises';
import TOML from '@iarna/toml';
import { ensureDirExists } from '../core/FileSystemUtils';
import * as path from 'path';
/* eslint-disable @typescript-eslint/no-explicit-any */
interface StdioServer {
  name: string;
  command: string;
  args?: string[];
  env?: Record<string, string>;
}
export async function propagateMcpToOpenHands(
  rulerMcpPath: string,
  openHandsConfigPath: string,
): Promise<void> {
  let rulerMcp;
  try {
    const rulerJsonContent = await fs.readFile(rulerMcpPath, 'utf8');
    rulerMcp = JSON.parse(rulerJsonContent);
  } catch {
    return;
  }
  const rulerServers = rulerMcp.mcpServers || {};
  let config: any = {};
  try {
    const tomlContent = await fs.readFile(openHandsConfigPath, 'utf8');
    config = TOML.parse(tomlContent);
  } catch {
    // File doesn't exist, we'll create it.
  }
  if (!config.mcp) {
    config.mcp = {};
  }
  if (!config.mcp.stdio_servers) {
    config.mcp.stdio_servers = [];
  }
  const existingServers = new Map<string, StdioServer>(
    config.mcp.stdio_servers.map((s: StdioServer) => [s.name, s]),
  );
  for (const [name, serverDef] of Object.entries(rulerServers)) {
    const { command, args, env } = serverDef as any;
    if (command) {
      const newServer: StdioServer = { name, command };
      if (args) newServer.args = args;
      if (env) newServer.env = env;
      existingServers.set(name, newServer);
    }
  }
  config.mcp.stdio_servers = Array.from(existingServers.values());
  await ensureDirExists(path.dirname(openHandsConfigPath));
  await fs.writeFile(openHandsConfigPath, TOML.stringify(config));
}
</file>

<file path="src/mcp/validate.ts">
/**
 * Validate the structure of the Ruler MCP JSON config.
 * Minimal validation: ensure 'mcpServers' property exists and is an object.
 * @param data Parsed JSON object from .ruler/mcp.json.
 * @throws Error if validation fails.
 */
export function validateMcp(data: unknown): void {
  if (
    !data ||
    typeof data !== 'object' ||
    !('mcpServers' in data) ||
    typeof (data as Record<string, unknown>).mcpServers !== 'object'
  ) {
    throw new Error(
      '[ruler] Invalid .ruler/mcp.json: must contain an object property "mcpServers"',
    );
  }
}
</file>

<file path="src/paths/mcp.ts">
import * as os from 'os';
import * as path from 'path';
import { promises as fs } from 'fs';
/** Determine the native MCP config path for a given agent. */
export async function getNativeMcpPath(
  adapterName: string,
  projectRoot: string,
): Promise<string | null> {
  const home = os.homedir();
  const candidates: string[] = [];
  switch (adapterName) {
    case 'GitHub Copilot':
      candidates.push(path.join(projectRoot, '.vscode', 'mcp.json'));
      break;
    case 'Visual Studio':
      candidates.push(path.join(projectRoot, '.mcp.json'));
      candidates.push(path.join(projectRoot, '.vs', 'mcp.json'));
      break;
    case 'Cursor':
      candidates.push(path.join(projectRoot, '.cursor', 'mcp.json'));
      candidates.push(path.join(home, '.cursor', 'mcp.json'));
      break;
    case 'Windsurf':
      candidates.push(
        path.join(home, '.codeium', 'windsurf', 'mcp_config.json'),
      );
      break;
    case 'Claude Code':
      candidates.push(path.join(projectRoot, 'claude_desktop_config.json'));
      break;
    case 'OpenAI Codex CLI':
      candidates.push(path.join(home, '.codex', 'config.json'));
      break;
    case 'Aider':
      candidates.push(path.join(projectRoot, '.mcp.json'));
      break;
    case 'Open Hands':
      // For Open Hands, we target the main config file, not a separate mcp.json
      candidates.push(path.join(projectRoot, '.openhands', 'config.toml'));
      break;
    default:
      return null;
  }
  for (const p of candidates) {
    try {
      await fs.access(p);
      return p;
    } catch {
      // continue
    }
  }
  // default to first candidate if none exist
  return candidates.length > 0 ? candidates[0] : null;
}
/** Read native MCP config from disk, or return empty object if missing/invalid. */
export async function readNativeMcp(
  filePath: string,
): Promise<Record<string, unknown>> {
  try {
    const text = await fs.readFile(filePath, 'utf8');
    return JSON.parse(text) as Record<string, unknown>;
  } catch {
    return {};
  }
}
/** Write native MCP config to disk, creating parent directories as needed. */
export async function writeNativeMcp(
  filePath: string,
  data: unknown,
): Promise<void> {
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  const text = JSON.stringify(data, null, 2) + '\n';
  await fs.writeFile(filePath, text, 'utf8');
}
</file>

<file path="src/constants.ts">
export const ERROR_PREFIX = '[RulerError]';
export function createRulerError(message: string, context?: string): Error {
  const fullMessage = context
    ? `${ERROR_PREFIX} ${message} (Context: ${context})`
    : `${ERROR_PREFIX} ${message}`;
  return new Error(fullMessage);
}
export function logVerbose(message: string, isVerbose: boolean): void {
  if (isVerbose) {
    console.error(`[ruler:verbose] ${message}`);
  }
}
</file>

<file path="src/types.ts">
/**
 * Types for Model Context Protocol (MCP) server configuration.
 */
export type McpStrategy = 'merge' | 'overwrite';
/** MCP configuration for an agent or global. */
export interface McpConfig {
  /** Enable or disable MCP propagation (merge or overwrite). */
  enabled?: boolean;
  /** Merge strategy: 'merge' to merge servers, 'overwrite' to replace config. */
  strategy?: McpStrategy;
}
/** Global MCP configuration section (same as agent-specific config). */
export type GlobalMcpConfig = McpConfig;
/** Gitignore configuration for automatic .gitignore file updates. */
export interface GitignoreConfig {
  /** Enable or disable automatic .gitignore updates. */
  enabled?: boolean;
}
</file>

<file path="test-qa/.ruler/instructions.md">
# Ruler Instructions

These are your centralised AI agent instructions.
Add your coding guidelines, style guides, and other project-specific context here.

Ruler will concatenate all .md files in this directory (and its subdirectories)
and apply them to your configured AI coding agents.
</file>

<file path="test-qa/.ruler/mcp.json">
{
  "mcpServers": {
    "example": {
      "url": "https://mcp.example.com"
    }
  }
}
</file>

<file path="test-qa/.ruler/ruler.toml">
# Ruler Configuration File
# See https://ai.intellectronica.net/ruler for documentation.

# To specify which agents are active by default when --agents is not used,
# uncomment and populate the following line. If omitted, all agents are active.
# default_agents = ["Copilot", "Claude"]

# --- Agent Specific Configurations ---
# You can enable/disable agents and override their default output paths here.

# [agents.GitHubCopilot]
# enabled = true
# output_path = ".github/copilot-instructions.md"

# [agents.ClaudeCode]
# enabled = true
# output_path = "CLAUDE.md"

# [agents.OpenAICodexCLI]
# enabled = true
# output_path = "AGENTS.md"

# [agents.Cursor]
# enabled = true
# output_path = ".cursor/rules/ruler_cursor_instructions.mdc"

# [agents.Windsurf]
# enabled = true
# output_path = ".windsurf/rules/ruler_windsurf_instructions.md"

# [agents.Cline]
# enabled = true
# output_path = ".clinerules"

# [agents.Aider]
# enabled = true
# output_path_instructions = "ruler_aider_instructions.md"
# output_path_config = ".aider.conf.yml"
</file>

<file path="test-qa/.gitignore">
# START Ruler Generated Files
CLAUDE.md
# END Ruler Generated Files
</file>

<file path="test-qa/claude_desktop_config.json">
{
  "mcpServers": {
    "example": {
      "url": "https://mcp.example.com"
    }
  }
}
</file>

<file path="tests/e2e/ruler.init.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { execSync } from 'child_process';
describe('End-to-End ruler init command', () => {
  let tmpDir: string;
  beforeAll(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-init-e2e-'));
  });
  afterAll(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  it('creates .ruler directory and default files', async () => {
    // Build and run init
    execSync('npm run build', { stdio: 'inherit' });
    execSync(`node dist/cli/index.js init --project-root ${tmpDir}`, {
      stdio: 'inherit',
    });
    const rulerDir = path.join(tmpDir, '.ruler');
    const instr = path.join(rulerDir, 'instructions.md');
    const toml = path.join(rulerDir, 'ruler.toml');
    await expect(fs.stat(rulerDir)).resolves.toBeDefined();
    await expect(
      fs.readFile(instr, 'utf8'),
    ).resolves.toMatch(/^# Ruler Instructions/);
    await expect(
      fs.readFile(toml, 'utf8'),
    ).resolves.toMatch(/^# Ruler Configuration File/);
  });
  it('does not overwrite existing files', async () => {
    const rulerDir = path.join(tmpDir, '.ruler');
    const instr = path.join(rulerDir, 'instructions.md');
    const toml = path.join(rulerDir, 'ruler.toml');
    // Prepopulate with markers
    await fs.writeFile(instr, 'KEEP');
    await fs.writeFile(toml, 'KEEP');
    execSync(`node dist/cli/index.js init --project-root ${tmpDir}`, { stdio: 'inherit' });
    expect(await fs.readFile(instr, 'utf8')).toBe('KEEP');
    expect(await fs.readFile(toml, 'utf8')).toBe('KEEP');
  });
});
</file>

<file path="tests/e2e/ruler.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import TOML from '@iarna/toml';
import { execSync } from 'child_process';
describe('End-to-End Ruler CLI', () => {
  let tmpDir: string;
  beforeAll(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-e2e-'));
    const rulerDir = path.join(tmpDir, '.ruler');
    await fs.mkdir(rulerDir, { recursive: true });
    await fs.writeFile(path.join(rulerDir, 'a.md'), 'Rule A');
    await fs.writeFile(path.join(rulerDir, 'b.md'), 'Rule B');
    // Provide a sample MCP config for Open Hands agent
    await fs.writeFile(
      path.join(rulerDir, 'mcp.json'),
      JSON.stringify({ mcpServers: { example: { command: 'uvx', args: ['mcp-example'] } } }),
    );
  });
  afterAll(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  beforeEach(async () => {
    // Clean up generated files before each test
    await fs.rm(path.join(tmpDir, '.github'), { recursive: true, force: true });
    await fs.rm(path.join(tmpDir, 'CLAUDE.md'), { force: true });
    await fs.rm(path.join(tmpDir, 'AGENTS.md'), { force: true });
    await fs.rm(path.join(tmpDir, '.cursor'), { recursive: true, force: true });
    await fs.rm(path.join(tmpDir, '.windsurf'), { recursive: true, force: true });
    await fs.rm(path.join(tmpDir, '.clinerules'), { force: true });
    await fs.rm(path.join(tmpDir, 'ruler_aider_instructions.md'), { force: true });
    await fs.rm(path.join(tmpDir, '.aider.conf.yml'), { force: true });
    await fs.rm(path.join(tmpDir, '.idx'), { recursive: true, force: true });
    await fs.rm(path.join(tmpDir, '.gitignore'), { force: true });
    // Clean up any custom files from previous tests
    await fs.rm(path.join(tmpDir, 'awesome.md'), { force: true });
    await fs.rm(path.join(tmpDir, 'custom-claude.md'), { force: true });
    await fs.rm(path.join(tmpDir, 'custom_cursor.md'), { force: true });
    // Reset the TOML config to default state
    await fs.rm(path.join(tmpDir, '.ruler', 'ruler.toml'), { force: true });
    // Clean up Open Hands agent files
    await fs.rm(path.join(tmpDir, '.openhands'), { recursive: true, force: true });
  });
  it('generates configuration files for all agents', () => {
    // Ensure latest build
    execSync('npm run build', { stdio: 'inherit' });
    // Run the CLI
    execSync(`node dist/cli/index.js apply --project-root ${tmpDir}`, { stdio: 'inherit' });
    // Check some generated files contain concatenated rules
    const copilotPath = path.join(tmpDir, '.github', 'copilot-instructions.md');
    const claudePath = path.join(tmpDir, 'CLAUDE.md');
    const codexPath = path.join(tmpDir, 'AGENTS.md');
    const cursorPath = path.join(tmpDir, '.cursor', 'rules', 'ruler_cursor_instructions.mdc');
    const windsurfPath = path.join(tmpDir, '.windsurf', 'rules', 'ruler_windsurf_instructions.md');
    const clinePath = path.join(tmpDir, '.clinerules');
    const aiderMd = path.join(tmpDir, 'ruler_aider_instructions.md');
    const aiderCfg = path.join(tmpDir, '.aider.conf.yml');
    const firebasePath = path.join(tmpDir, '.idx', 'airules.md');
    const openHandsInstructionsPath = path.join(
      tmpDir,
      '.openhands',
      'microagents',
      'repo.md',
    );
    const openHandsConfigPath = path.join(
      tmpDir,
      '.openhands',
      'config.toml',
    );
    return Promise.all([
      expect(fs.readFile(copilotPath, 'utf8')).resolves.toContain('Rule A'),
      expect(fs.readFile(claudePath, 'utf8')).resolves.toContain('Rule B'),
      expect(fs.readFile(codexPath, 'utf8')).resolves.toContain('Rule A'),
      expect(fs.readFile(cursorPath, 'utf8')).resolves.toContain('Rule B'),
      expect(fs.readFile(windsurfPath, 'utf8')).resolves.toContain('Rule A'),
      expect(fs.readFile(clinePath, 'utf8')).resolves.toContain('Rule B'),
      expect(fs.readFile(aiderMd, 'utf8')).resolves.toContain('Rule A'),
      expect(fs.readFile(aiderCfg, 'utf8')).resolves.toContain('ruler_aider_instructions.md'),
      expect(fs.readFile(firebasePath, 'utf8')).resolves.toContain('Rule B'),
      expect(
        fs.readFile(openHandsInstructionsPath, 'utf8'),
      ).resolves.toContain('Rule A'),
    ])
      .then(async () => {
        const ohToml = await fs.readFile(openHandsConfigPath, 'utf8');
        const ohParsed: any = TOML.parse(ohToml);
        expect(ohParsed.mcp.stdio_servers[0].name).toBe('example');
      });
  });
  it('respects default_agents in config file', async () => {
    const toml = `default_agents = ["GitHub Copilot", "Claude Code"]`;
    await fs.writeFile(path.join(tmpDir, '.ruler', 'ruler.toml'), toml);
    execSync(`node dist/cli/index.js apply --project-root ${tmpDir}`, { stdio: 'inherit' });
    await expect(
      fs.readFile(path.join(tmpDir, '.github', 'copilot-instructions.md'), 'utf8'),
    ).resolves.toContain('Rule A');
    await expect(
      fs.readFile(path.join(tmpDir, 'CLAUDE.md'), 'utf8'),
    ).resolves.toContain('Rule B');
    await expect(
      fs.stat(path.join(tmpDir, 'AGENTS.md')),
    ).rejects.toThrow();
  });
  it('CLI --agents overrides default_agents', async () => {
    const toml = `default_agents = ["GitHub Copilot", "Claude Code"]`;
    await fs.writeFile(path.join(tmpDir, '.ruler', 'ruler.toml'), toml);
    execSync(
      `node dist/cli/index.js apply --project-root ${tmpDir} --agents codex`,
      { stdio: 'inherit' },
    );
    await expect(
      fs.readFile(path.join(tmpDir, 'AGENTS.md'), 'utf8'),
    ).resolves.toContain('Rule A');
    await expect(
      fs.stat(path.join(tmpDir, '.github', 'copilot-instructions.md')),
    ).rejects.toThrow();
  });
  it('CLI --agents firebase creates .idx/airules.md', async () => {
    execSync(
      `node dist/cli/index.js apply --project-root ${tmpDir} --agents firebase`,
      { stdio: 'inherit' },
    );
    const firebasePath = path.join(tmpDir, '.idx', 'airules.md');
    await expect(
      fs.readFile(firebasePath, 'utf8'),
    ).resolves.toContain('Rule A');
    await expect(
      fs.readFile(firebasePath, 'utf8'),
    ).resolves.toContain('Rule B');
    // Ensure no other agent files were created
    await expect(
      fs.stat(path.join(tmpDir, '.github', 'copilot-instructions.md')),
    ).rejects.toThrow();
    await expect(
      fs.stat(path.join(tmpDir, 'CLAUDE.md')),
    ).rejects.toThrow();
  });
  it('uses custom config file via --config', async () => {
    const alt = path.join(tmpDir, 'custom.toml');
    const toml = `default_agents = ["Cursor"]
[agents.Cursor]
output_path = "custom_cursor.md"
`;
    await fs.writeFile(alt, toml);
    execSync(
      `node dist/cli/index.js apply --project-root ${tmpDir} --config ${alt}`,
      { stdio: 'inherit' },
    );
    await expect(
      fs.readFile(path.join(tmpDir, 'custom_cursor.md'), 'utf8'),
    ).resolves.toContain('Rule A');
  });
  it('honors custom output_path in config', async () => {
    const toml = `
[agents.Copilot]
output_path = "awesome.md"
`;
    await fs.writeFile(path.join(tmpDir, '.ruler', 'ruler.toml'), toml);
    execSync(`node dist/cli/index.js apply --project-root ${tmpDir}`, { stdio: 'inherit' });
    await expect(
      fs.readFile(path.join(tmpDir, 'awesome.md'), 'utf8'),
    ).resolves.toContain('Rule A');
  });
  describe('gitignore CLI flags', () => {
    it('accepts --gitignore flag without error', () => {
      execSync('npm run build', { stdio: 'inherit' });
      expect(() => {
        execSync(
          `node dist/cli/index.js apply --project-root ${tmpDir} --gitignore`,
          { stdio: 'inherit' }
        );
      }).not.toThrow();
    });
    it('accepts --no-gitignore flag without error', () => {
      execSync('npm run build', { stdio: 'inherit' });
      expect(() => {
        execSync(
          `node dist/cli/index.js apply --project-root ${tmpDir} --no-gitignore`,
          { stdio: 'inherit' }
        );
      }).not.toThrow();
    });
    it('accepts both --gitignore and --no-gitignore with precedence to --no-gitignore', () => {
      execSync('npm run build', { stdio: 'inherit' });
      expect(() => {
        execSync(
          `node dist/cli/index.js apply --project-root ${tmpDir} --gitignore --no-gitignore`,
          { stdio: 'inherit' }
        );
      }).not.toThrow();
    });
  });
  describe('gitignore integration', () => {
    it('creates .gitignore with generated file paths by default', async () => {
      execSync('npm run build', { stdio: 'inherit' });
      execSync(`node dist/cli/index.js apply --project-root ${tmpDir}`, { stdio: 'inherit' });
      const gitignorePath = path.join(tmpDir, '.gitignore');
      const gitignoreContent = await fs.readFile(gitignorePath, 'utf8');
      expect(gitignoreContent).toContain('# START Ruler Generated Files');
      expect(gitignoreContent).toContain('# END Ruler Generated Files');
      expect(gitignoreContent).toContain('CLAUDE.md');
      expect(gitignoreContent).toContain('.github/copilot-instructions.md');
      expect(gitignoreContent).toContain('AGENTS.md');
      expect(gitignoreContent).toContain('.cursor/rules/ruler_cursor_instructions.mdc');
      expect(gitignoreContent).toContain('.windsurf/rules/ruler_windsurf_instructions.md');
      expect(gitignoreContent).toContain('.clinerules');
      expect(gitignoreContent).toContain('ruler_aider_instructions.md');
      expect(gitignoreContent).toContain('.aider.conf.yml');
      expect(gitignoreContent).toContain('.idx/airules.md');
      expect(gitignoreContent).toContain('.openhands/microagents/repo.md');
      expect(gitignoreContent).toContain('.openhands/config.toml');
      expect(gitignoreContent).toContain('.openhands/microagents/repo.md');
      expect(gitignoreContent).toContain('.openhands/config.toml');
    });
    it('does not update .gitignore when --no-gitignore is used', async () => {
      execSync('npm run build', { stdio: 'inherit' });
      execSync(`node dist/cli/index.js apply --project-root ${tmpDir} --no-gitignore`, { stdio: 'inherit' });
      const gitignorePath = path.join(tmpDir, '.gitignore');
      await expect(fs.access(gitignorePath)).rejects.toThrow();
    });
    it('respects [gitignore] enabled = false in TOML config', async () => {
      const toml = `[gitignore]
enabled = false`;
      await fs.writeFile(path.join(tmpDir, '.ruler', 'ruler.toml'), toml);
      execSync('npm run build', { stdio: 'inherit' });
      execSync(`node dist/cli/index.js apply --project-root ${tmpDir}`, { stdio: 'inherit' });
      const gitignorePath = path.join(tmpDir, '.gitignore');
      await expect(fs.access(gitignorePath)).rejects.toThrow();
    });
    it('CLI --no-gitignore overrides TOML enabled = true', async () => {
      const toml = `[gitignore]
enabled = true`;
      await fs.writeFile(path.join(tmpDir, '.ruler', 'ruler.toml'), toml);
      execSync('npm run build', { stdio: 'inherit' });
      execSync(`node dist/cli/index.js apply --project-root ${tmpDir} --no-gitignore`, { stdio: 'inherit' });
      const gitignorePath = path.join(tmpDir, '.gitignore');
      await expect(fs.access(gitignorePath)).rejects.toThrow();
    });
    it('updates existing .gitignore preserving other content', async () => {
      const gitignorePath = path.join(tmpDir, '.gitignore');
      await fs.writeFile(gitignorePath, 'node_modules/\n*.log\n');
      execSync('npm run build', { stdio: 'inherit' });
      execSync(`node dist/cli/index.js apply --project-root ${tmpDir}`, { stdio: 'inherit' });
      const gitignoreContent = await fs.readFile(gitignorePath, 'utf8');
      expect(gitignoreContent).toContain('node_modules/');
      expect(gitignoreContent).toContain('*.log');
      expect(gitignoreContent).toContain('# START Ruler Generated Files');
      expect(gitignoreContent).toContain('CLAUDE.md');
      expect(gitignoreContent).toContain('# END Ruler Generated Files');
    });
    it('respects custom output paths in .gitignore', async () => {
      const toml = `[agents.Claude]
output_path = "custom-claude.md"`;
      await fs.writeFile(path.join(tmpDir, '.ruler', 'ruler.toml'), toml);
      execSync('npm run build', { stdio: 'inherit' });
      execSync(`node dist/cli/index.js apply --project-root ${tmpDir} --agents claude`, { stdio: 'inherit' });
      const gitignorePath = path.join(tmpDir, '.gitignore');
      const gitignoreContent = await fs.readFile(gitignorePath, 'utf8');
      expect(gitignoreContent).toContain('custom-claude.md');
      expect(gitignoreContent).not.toContain('CLAUDE.md');
    });
  });
});
</file>

<file path="tests/integration/lowercase-identifiers.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { applyAllAgentConfigs } from '../../src/lib';
describe('Lowercase Identifiers Integration', () => {
  let tmpDir: string;
  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-lowercase-integration-'));
    // Create .ruler directory with basic files
    const rulerDir = path.join(tmpDir, '.ruler');
    await fs.mkdir(rulerDir, { recursive: true });
    await fs.writeFile(path.join(rulerDir, 'instructions.md'), '# Test instructions');
  });
  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  it('supports lowercase identifiers in CLI --agents option', async () => {
    // Create a config with mixed case
    const configContent = `
[agents.COPILOT]
enabled = true
[agents.Claude]  
enabled = true
`;
    await fs.writeFile(path.join(tmpDir, '.ruler', 'ruler.toml'), configContent);
    // Test with lowercase CLI identifiers - this should work
    await expect(
      applyAllAgentConfigs(
        tmpDir,
        ['copilot', 'claude'], // lowercase identifiers
        undefined,
        false, // no MCP
        undefined,
        false, // no gitignore
        false, // not verbose
        true, // dry run
      )
    ).resolves.not.toThrow();
  });
  it('supports lowercase identifiers in default_agents config', async () => {
    const configContent = `
default_agents = ["copilot", "claude"]
[agents.copilot]
enabled = true
[agents.claude]
enabled = true
`;
    await fs.writeFile(path.join(tmpDir, '.ruler', 'ruler.toml'), configContent);
    // Test that lowercase default_agents work
    await expect(
      applyAllAgentConfigs(
        tmpDir,
        undefined, // no CLI agents
        undefined,
        false, // no MCP
        undefined,
        false, // no gitignore
        false, // not verbose
        true, // dry run
      )
    ).resolves.not.toThrow();
  });
  it('normalizes mixed case config keys to work with lowercase identifiers', async () => {
    const configContent = `
[agents.COPILOT]
enabled = true
output_path = "CUSTOM_COPILOT.md"
[agents.Claude]
enabled = false
[agents.aider]
enabled = true
`;
    await fs.writeFile(path.join(tmpDir, '.ruler', 'ruler.toml'), configContent);
    // Test with lowercase CLI filters
    await expect(
      applyAllAgentConfigs(
        tmpDir,
        ['copilot', 'aider'], // Should find COPILOT and aider configs
        undefined,
        false, // no MCP
        undefined,
        false, // no gitignore
        false, // not verbose
        true, // dry run
      )
    ).resolves.not.toThrow();
  });
});
</file>

<file path="tests/unit/agents/GeminiCliAgent.test.ts">
import { GeminiCliAgent } from '../../../src/agents/GeminiCliAgent';
describe('GeminiCliAgent', () => {
  it('should be defined', () => {
    expect(new GeminiCliAgent()).toBeDefined();
  });
});
</file>

<file path="tests/unit/agents/LowercaseIdentifiers.test.ts">
import { CopilotAgent } from '../../../src/agents/CopilotAgent';
import { ClaudeAgent } from '../../../src/agents/ClaudeAgent';
import { CodexCliAgent } from '../../../src/agents/CodexCliAgent';
import { CursorAgent } from '../../../src/agents/CursorAgent';
import { WindsurfAgent } from '../../../src/agents/WindsurfAgent';
import { ClineAgent } from '../../../src/agents/ClineAgent';
import { AiderAgent } from '../../../src/agents/AiderAgent';
describe('Agent Lowercase Identifiers', () => {
  const expectedIdentifiers = {
    copilot: CopilotAgent,
    claude: ClaudeAgent,
    codex: CodexCliAgent,
    cursor: CursorAgent,
    windsurf: WindsurfAgent,
    cline: ClineAgent,
    aider: AiderAgent,
  };
  describe('Agent.getIdentifier() returns lowercase identifiers', () => {
    Object.entries(expectedIdentifiers).forEach(([expectedId, AgentClass]) => {
      it(`${AgentClass.name} returns "${expectedId}"`, () => {
        const agent = new AgentClass();
        expect(agent.getIdentifier()).toBe(expectedId);
      });
    });
  });
  describe('Agent.getName() returns display names', () => {
    const expectedDisplayNames = {
      copilot: 'GitHub Copilot',
      claude: 'Claude Code',
      codex: 'OpenAI Codex CLI',
      cursor: 'Cursor',
      windsurf: 'Windsurf',
      cline: 'Cline',
      aider: 'Aider',
    };
    Object.entries(expectedIdentifiers).forEach(([identifier, AgentClass]) => {
      it(`${AgentClass.name} returns "${expectedDisplayNames[identifier as keyof typeof expectedDisplayNames]}"`, () => {
        const agent = new AgentClass();
        expect(agent.getName()).toBe(expectedDisplayNames[identifier as keyof typeof expectedDisplayNames]);
      });
    });
  });
});
</file>

<file path="tests/unit/core/ConfigLoader.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { loadConfig, LoadedConfig } from '../../../src/core/ConfigLoader';
describe('ConfigLoader', () => {
  let tmpDir: string;
  let rulerDir: string;
  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-config-'));
    rulerDir = path.join(tmpDir, '.ruler');
    await fs.mkdir(rulerDir, { recursive: true });
  });
  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  it('returns empty config when file does not exist', async () => {
    const config = await loadConfig({ projectRoot: tmpDir });
    expect(config.defaultAgents).toBeUndefined();
    expect(config.agentConfigs).toEqual({});
    expect(config.cliAgents).toBeUndefined();
  });
  it('returns empty config when file is empty', async () => {
    await fs.writeFile(path.join(rulerDir, 'ruler.toml'), '');
    const config = await loadConfig({ projectRoot: tmpDir });
    expect(config.defaultAgents).toBeUndefined();
    expect(config.agentConfigs).toEqual({});
  });
  it('parses default_agents', async () => {
    const content = `default_agents = ["A", "B"]`;
    await fs.writeFile(path.join(rulerDir, 'ruler.toml'), content);
    const config = await loadConfig({ projectRoot: tmpDir });
    expect(config.defaultAgents).toEqual(['A', 'B']);
  });
  it('parses agent enabled overrides', async () => {
    const content = `
      [agents.A]
      enabled = false
      [agents.B]
      enabled = true
    `;
    await fs.writeFile(path.join(rulerDir, 'ruler.toml'), content);
    const config = await loadConfig({ projectRoot: tmpDir });
    expect(config.agentConfigs.A.enabled).toBe(false);
    expect(config.agentConfigs.B.enabled).toBe(true);
  });
  it('parses agent output_path and resolves to projectRoot', async () => {
    const content = `
      [agents.A]
      output_path = "foo/bar.md"
    `;
    await fs.writeFile(path.join(rulerDir, 'ruler.toml'), content);
    const config = await loadConfig({ projectRoot: tmpDir });
    expect(config.agentConfigs.A.outputPath).toBe(
      path.resolve(tmpDir, 'foo/bar.md'),
    );
});
it('parses agent output_path_instructions and resolves to projectRoot', async () => {
  const content = `
    [agents.A]
    output_path_instructions = "foo/instructions.md"
  `;
  await fs.writeFile(path.join(rulerDir, 'ruler.toml'), content);
  const config = await loadConfig({ projectRoot: tmpDir });
  expect(config.agentConfigs.A.outputPathInstructions).toBe(
    path.resolve(tmpDir, 'foo/instructions.md'),
  );
});
it('parses agent output_path_config and resolves to projectRoot', async () => {
  const content = `
    [agents.A]
    output_path_config = "foo/config.toml"
  `;
  await fs.writeFile(path.join(rulerDir, 'ruler.toml'), content);
  const config = await loadConfig({ projectRoot: tmpDir });
  expect(config.agentConfigs.A.outputPathConfig).toBe(
    path.resolve(tmpDir, 'foo/config.toml'),
  );
});
it('loads config from custom path via configPath option', async () => {
    const altDir = path.join(tmpDir, 'alt');
    await fs.mkdir(altDir, { recursive: true });
    const altPath = path.join(altDir, 'myconfig.toml');
    await fs.writeFile(altPath, `default_agents = ["X"]`);
    const config = await loadConfig({ projectRoot: tmpDir, configPath: altPath });
    expect(config.defaultAgents).toEqual(['X']);
  });
  it('captures CLI agents override', async () => {
    const overrides = ['C', 'D'];
    const config = await loadConfig({ projectRoot: tmpDir, cliAgents: overrides });
    expect(config.cliAgents).toEqual(overrides);
  });
  describe('gitignore configuration', () => {
    it('parses [gitignore] section with enabled = true', async () => {
      const content = `
        [gitignore]
        enabled = true
      `;
      await fs.writeFile(path.join(rulerDir, 'ruler.toml'), content);
      const config = await loadConfig({ projectRoot: tmpDir });
      expect(config.gitignore).toBeDefined();
      expect(config.gitignore?.enabled).toBe(true);
    });
    it('parses [gitignore] section with enabled = false', async () => {
      const content = `
        [gitignore]
        enabled = false
      `;
      await fs.writeFile(path.join(rulerDir, 'ruler.toml'), content);
      const config = await loadConfig({ projectRoot: tmpDir });
      expect(config.gitignore).toBeDefined();
      expect(config.gitignore?.enabled).toBe(false);
    });
    it('parses [gitignore] section with missing enabled key', async () => {
      const content = `
        [gitignore]
        # enabled key not specified
      `;
      await fs.writeFile(path.join(rulerDir, 'ruler.toml'), content);
      const config = await loadConfig({ projectRoot: tmpDir });
      expect(config.gitignore).toBeDefined();
      expect(config.gitignore?.enabled).toBeUndefined();
    });
    it('handles missing [gitignore] section', async () => {
      const content = `
        default_agents = ["A"]
      `;
      await fs.writeFile(path.join(rulerDir, 'ruler.toml'), content);
      const config = await loadConfig({ projectRoot: tmpDir });
      expect(config.gitignore).toBeDefined();
      expect(config.gitignore?.enabled).toBeUndefined();
    });
    it('handles empty config file for gitignore', async () => {
      await fs.writeFile(path.join(rulerDir, 'ruler.toml'), '');
      const config = await loadConfig({ projectRoot: tmpDir });
      expect(config.gitignore).toBeDefined();
      expect(config.gitignore?.enabled).toBeUndefined();
    });
  });
});
</file>

<file path="tests/unit/core/constants.test.ts">
import { logVerbose } from '../../../src/constants';
describe('constants', () => {
  describe('logVerbose', () => {
    let consoleErrorSpy: jest.SpyInstance;
    let consoleLogSpy: jest.SpyInstance;
    beforeEach(() => {
      consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();
      consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();
    });
    afterEach(() => {
      consoleErrorSpy.mockRestore();
      consoleLogSpy.mockRestore();
    });
    it('calls console.error when isVerbose is true', () => {
      logVerbose('test message', true);
      expect(consoleErrorSpy).toHaveBeenCalledWith('[ruler:verbose] test message');
      expect(consoleLogSpy).not.toHaveBeenCalled();
    });
    it('does not call console.error or console.log when isVerbose is false', () => {
      logVerbose('test message', false);
      expect(consoleErrorSpy).not.toHaveBeenCalled();
      expect(consoleLogSpy).not.toHaveBeenCalled();
    });
    it('calls console.error with the correct message format', () => {
      const message = 'verbose debug information';
      logVerbose(message, true);
      expect(consoleErrorSpy).toHaveBeenCalledTimes(1);
      expect(consoleErrorSpy).toHaveBeenCalledWith(`[ruler:verbose] ${message}`);
    });
  });
});
</file>

<file path="tests/unit/core/FileSystemUtils.test.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs/promises"));
const path = __importStar(require("path"));
const os_1 = __importDefault(require("os"));
const FileSystemUtils_1 = require("../../../src/core/FileSystemUtils");
describe('FileSystemUtils', () => {
    let tmpDir;
    beforeAll(async () => {
        tmpDir = await fs.mkdtemp(path.join(os_1.default.tmpdir(), 'ruler-test-'));
    });
    afterAll(async () => {
        await fs.rm(tmpDir, { recursive: true, force: true });
    });
    describe('findRulerDir', () => {
        it('finds .ruler in parent directories', async () => {
            const projectDir = path.join(tmpDir, 'project');
            const rulerDir = path.join(projectDir, '.ruler');
            const nestedDir = path.join(projectDir, 'sub', 'child');
            await fs.mkdir(rulerDir, { recursive: true });
            await fs.mkdir(nestedDir, { recursive: true });
            const found = await (0, FileSystemUtils_1.findRulerDir)(nestedDir);
            expect(found).toBe(rulerDir);
        });
        it('returns null if .ruler is not found', async () => {
            const someDir = path.join(tmpDir, 'nofile');
            await fs.mkdir(someDir, { recursive: true });
            const found = await (0, FileSystemUtils_1.findRulerDir)(someDir);
            expect(found).toBeNull();
        });
    });
    describe('readMarkdownFiles', () => {
        it('reads and sorts markdown files', async () => {
            const rulerDir = path.join(tmpDir, '.ruler2');
            const subDir = path.join(rulerDir, 'sub');
            await fs.mkdir(subDir, { recursive: true });
            const fileA = path.join(rulerDir, 'a.md');
            const fileB = path.join(subDir, 'b.md');
            await fs.writeFile(fileA, 'contentA');
            await fs.writeFile(fileB, 'contentB');
            const files = await (0, FileSystemUtils_1.readMarkdownFiles)(rulerDir);
            expect(files.map((f) => f.path)).toEqual([fileA, fileB]);
            expect(files[0].content).toBe('contentA');
            expect(files[1].content).toBe('contentB');
        });
    });
});
</file>

<file path="tests/unit/core/FileSystemUtils.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { findRulerDir, readMarkdownFiles } from '../../../src/core/FileSystemUtils';
describe('FileSystemUtils', () => {
  let tmpDir: string;
  beforeAll(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-test-'));
  });
  afterAll(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  describe('findRulerDir', () => {
    it('finds .ruler in parent directories', async () => {
      const projectDir = path.join(tmpDir, 'project');
      const rulerDir = path.join(projectDir, '.ruler');
      const nestedDir = path.join(projectDir, 'sub', 'child');
      await fs.mkdir(rulerDir, { recursive: true });
      await fs.mkdir(nestedDir, { recursive: true });
      const found = await findRulerDir(nestedDir);
      expect(found).toBe(rulerDir);
    });
    it('returns null if .ruler is not found', async () => {
      const someDir = path.join(tmpDir, 'nofile');
      await fs.mkdir(someDir, { recursive: true });
      const found = await findRulerDir(someDir);
      expect(found).toBeNull();
    });
  });
  describe('readMarkdownFiles', () => {
    it('reads and sorts markdown files', async () => {
      const rulerDir = path.join(tmpDir, '.ruler2');
      const subDir = path.join(rulerDir, 'sub');
      await fs.mkdir(subDir, { recursive: true });
      const fileA = path.join(rulerDir, 'a.md');
      const fileB = path.join(subDir, 'b.md');
      await fs.writeFile(fileA, 'contentA');
      await fs.writeFile(fileB, 'contentB');
      const files = await readMarkdownFiles(rulerDir);
      expect(files.map((f) => f.path)).toEqual([fileA, fileB]);
      expect(files[0].content).toBe('contentA');
      expect(files[1].content).toBe('contentB');
    });
  });
});
</file>

<file path="tests/unit/core/GitignoreUtils.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { updateGitignore } from '../../../src/core/GitignoreUtils';
describe('GitignoreUtils', () => {
  let tmpDir: string;
  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-gitignore-'));
  });
  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  describe('updateGitignore', () => {
    it('creates .gitignore with Ruler block when file does not exist', async () => {
      const paths = ['CLAUDE.md', '.cursor/rules/ruler_cursor_instructions.mdc'];
      const gitignorePath = path.join(tmpDir, '.gitignore');
      await updateGitignore(tmpDir, paths);
      const content = await fs.readFile(gitignorePath, 'utf8');
      expect(content).toContain('# START Ruler Generated Files');
      expect(content).toContain('# END Ruler Generated Files');
      expect(content).toContain('CLAUDE.md');
      expect(content).toContain('.cursor/rules/ruler_cursor_instructions.mdc');
    });
    it('creates .gitignore with empty block when no paths provided', async () => {
      const gitignorePath = path.join(tmpDir, '.gitignore');
      await updateGitignore(tmpDir, []);
      const content = await fs.readFile(gitignorePath, 'utf8');
      expect(content).toContain('# START Ruler Generated Files');
      expect(content).toContain('# END Ruler Generated Files');
      expect(content.split('\n').length).toBe(4); // header, blank, footer, final newline
    });
    it('updates existing empty .gitignore file', async () => {
      const paths = ['CLAUDE.md'];
      const gitignorePath = path.join(tmpDir, '.gitignore');
      await fs.writeFile(gitignorePath, '');
      await updateGitignore(tmpDir, paths);
      const content = await fs.readFile(gitignorePath, 'utf8');
      expect(content).toContain('# START Ruler Generated Files');
      expect(content).toContain('CLAUDE.md');
      expect(content).toContain('# END Ruler Generated Files');
    });
    it('updates existing .gitignore with other content', async () => {
      const paths = ['CLAUDE.md'];
      const gitignorePath = path.join(tmpDir, '.gitignore');
      await fs.writeFile(gitignorePath, 'node_modules/\n*.log\n');
      await updateGitignore(tmpDir, paths);
      const content = await fs.readFile(gitignorePath, 'utf8');
      expect(content).toContain('node_modules/');
      expect(content).toContain('*.log');
      expect(content).toContain('# START Ruler Generated Files');
      expect(content).toContain('CLAUDE.md');
      expect(content).toContain('# END Ruler Generated Files');
    });
    it('replaces existing Ruler block with new paths', async () => {
      const paths = ['CLAUDE.md', 'AGENTS.md'];
      const gitignorePath = path.join(tmpDir, '.gitignore');
      const initialContent = `node_modules/
# START Ruler Generated Files
.cursor/rules/ruler_cursor_instructions.mdc
# END Ruler Generated Files
*.log`;
      await fs.writeFile(gitignorePath, initialContent);
      await updateGitignore(tmpDir, paths);
      const content = await fs.readFile(gitignorePath, 'utf8');
      expect(content).toContain('node_modules/');
      expect(content).toContain('*.log');
      expect(content).toContain('CLAUDE.md');
      expect(content).toContain('AGENTS.md');
      expect(content).not.toContain('.cursor/rules/ruler_cursor_instructions.mdc');
    });
    it('sorts paths alphabetically within Ruler block', async () => {
      const paths = ['z-file.md', 'a-file.md', 'b-file.md'];
      const gitignorePath = path.join(tmpDir, '.gitignore');
      await updateGitignore(tmpDir, paths);
      const content = await fs.readFile(gitignorePath, 'utf8');
      const lines = content.split('\n');
      const startIndex = lines.findIndex(line => line === '# START Ruler Generated Files');
      const endIndex = lines.findIndex(line => line === '# END Ruler Generated Files');
      const rulerLines = lines.slice(startIndex + 1, endIndex).filter(line => line.trim());
      expect(rulerLines).toEqual(['a-file.md', 'b-file.md', 'z-file.md']);
    });
    it('maintains idempotency - no duplicates in Ruler block', async () => {
      const paths = ['CLAUDE.md', 'AGENTS.md'];
      const gitignorePath = path.join(tmpDir, '.gitignore');
      // First update
      await updateGitignore(tmpDir, paths);
      // Second update with same paths
      await updateGitignore(tmpDir, paths);
      const content = await fs.readFile(gitignorePath, 'utf8');
      const claudeMatches = (content.match(/CLAUDE\.md/g) || []).length;
      const agentsMatches = (content.match(/AGENTS\.md/g) || []).length;
      expect(claudeMatches).toBe(1);
      expect(agentsMatches).toBe(1);
    });
    it('does not add paths that already exist outside Ruler block', async () => {
      const paths = ['CLAUDE.md', 'AGENTS.md'];
      const gitignorePath = path.join(tmpDir, '.gitignore');
      const initialContent = `node_modules/
CLAUDE.md
*.log`;
      await fs.writeFile(gitignorePath, initialContent);
      await updateGitignore(tmpDir, paths);
      const content = await fs.readFile(gitignorePath, 'utf8');
      const claudeMatches = (content.match(/CLAUDE\.md/g) || []).length;
      // Should only appear once (outside the Ruler block)
      expect(claudeMatches).toBe(1);
      expect(content).toContain('AGENTS.md');
    });
    it('converts paths to POSIX format', async () => {
      const paths = ['.cursor\\rules\\ruler_cursor_instructions.mdc'];
      const gitignorePath = path.join(tmpDir, '.gitignore');
      await updateGitignore(tmpDir, paths);
      const content = await fs.readFile(gitignorePath, 'utf8');
      expect(content).toContain('.cursor/rules/ruler_cursor_instructions.mdc');
      expect(content).not.toContain('\\');
    });
    it('makes paths relative to project root', async () => {
      const absolutePaths = [
        path.join(tmpDir, 'CLAUDE.md'),
        path.join(tmpDir, 'subdir', 'AGENTS.md')
      ];
      const gitignorePath = path.join(tmpDir, '.gitignore');
      await updateGitignore(tmpDir, absolutePaths);
      const content = await fs.readFile(gitignorePath, 'utf8');
      expect(content).toContain('CLAUDE.md');
      expect(content).toContain('subdir/AGENTS.md');
      expect(content).not.toContain(tmpDir);
    });
    it('handles multiple Ruler blocks by updating the first one', async () => {
      const paths = ['CLAUDE.md'];
      const gitignorePath = path.join(tmpDir, '.gitignore');
      const initialContent = `# START Ruler Generated Files
old-file.md
# END Ruler Generated Files
some-other-content
# START Ruler Generated Files
duplicate-block.md
# END Ruler Generated Files`;
      await fs.writeFile(gitignorePath, initialContent);
      await updateGitignore(tmpDir, paths);
      const content = await fs.readFile(gitignorePath, 'utf8');
      expect(content).toContain('CLAUDE.md');
      expect(content).not.toContain('old-file.md');
      // Should still contain the duplicate block
      expect(content).toContain('duplicate-block.md');
    });
  });
});
</file>

<file path="tests/unit/core/LowercaseConfig.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { loadConfig } from '../../../src/core/ConfigLoader';
import { applyAllAgentConfigs } from '../../../src/lib';
describe('Lowercase Configuration Support', () => {
  let tmpDir: string;
  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-lowercase-config-'));
    // Create .ruler directory
    const rulerDir = path.join(tmpDir, '.ruler');
    await fs.mkdir(rulerDir, { recursive: true });
    // Create a basic instructions file
    await fs.writeFile(path.join(rulerDir, 'instructions.md'), '# Test instructions');
  });
  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  it('supports lowercase agent identifiers in default_agents', async () => {
    const configContent = `
default_agents = ["copilot", "claude", "aider"]
[agents.copilot]
enabled = true
[agents.claude]
enabled = false
`;
    const configPath = path.join(tmpDir, '.ruler', 'ruler.toml');
    await fs.writeFile(configPath, configContent);
    const config = await loadConfig({
      projectRoot: tmpDir,
      configPath,
    });
    expect(config.defaultAgents).toEqual(['copilot', 'claude', 'aider']);
    expect(config.agentConfigs.copilot?.enabled).toBe(true);
    expect(config.agentConfigs.claude?.enabled).toBe(false);
  });
  it('supports mixed case agent identifiers in CLI agents', async () => {
    const config = await loadConfig({
      projectRoot: tmpDir,
      cliAgents: ['copilot', 'CLAUDE', 'Aider'],
    });
    expect(config.cliAgents).toEqual(['copilot', 'CLAUDE', 'Aider']);
  });
  it('normalizes agent config keys to lowercase', async () => {
    const configContent = `
[agents.COPILOT]
enabled = true
[agents.Claude]
enabled = false
[agents.aider]
enabled = true
`;
    const configPath = path.join(tmpDir, '.ruler', 'ruler.toml');
    await fs.writeFile(configPath, configContent);
    const config = await loadConfig({
      projectRoot: tmpDir,
      configPath,
    });
    // ConfigLoader preserves the original casing, normalization happens in lib.ts
    expect(config.agentConfigs.COPILOT?.enabled).toBe(true);
    expect(config.agentConfigs.Claude?.enabled).toBe(false);
    expect(config.agentConfigs.aider?.enabled).toBe(true);
  });
  it('provides correct output paths for all agents', async () => {
    const configContent = `
[agents.copilot]
output_path = "custom/copilot.md"
[agents.claude]
output_path = "CUSTOM_CLAUDE.md"
[agents.aider]
output_path_instructions = "custom_aider.md"
output_path_config = "custom_aider.yml"
`;
    const configPath = path.join(tmpDir, '.ruler', 'ruler.toml');
    await fs.writeFile(configPath, configContent);
    const config = await loadConfig({
      projectRoot: tmpDir,
      configPath,
    });
    // ConfigLoader resolves paths to absolute paths
    expect(config.agentConfigs.copilot?.outputPath).toBe(path.join(tmpDir, 'custom/copilot.md'));
    expect(config.agentConfigs.claude?.outputPath).toBe(path.join(tmpDir, 'CUSTOM_CLAUDE.md'));
    expect(config.agentConfigs.aider?.outputPathInstructions).toBe(path.join(tmpDir, 'custom_aider.md'));
    expect(config.agentConfigs.aider?.outputPathConfig).toBe(path.join(tmpDir, 'custom_aider.yml'));
  });
});
</file>

<file path="tests/unit/core/RuleProcessor.test.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RuleProcessor_1 = require("../../../src/core/RuleProcessor");
describe('RuleProcessor', () => {
    it('concatenates and formats rule content with source markers', () => {
        const files = [
            { path: '/project/.ruler/a.md', content: 'A rule' },
            { path: '/project/.ruler/b.md', content: 'B rule' },
        ];
        jest.spyOn(process, 'cwd').mockReturnValue('/project');
        const result = (0, RuleProcessor_1.concatenateRules)(files);
        expect(result).toContain('Source: .ruler/a.md');
        expect(result).toContain('A rule');
        expect(result).toContain('Source: .ruler/b.md');
        expect(result).toContain('B rule');
    });
});
</file>

<file path="tests/unit/core/RuleProcessor.test.ts">
import * as path from 'path';
import { concatenateRules } from '../../../src/core/RuleProcessor';
describe('RuleProcessor', () => {
  it('concatenates and formats rule content with source markers', () => {
    const files = [
      { path: '/project/.ruler/a.md', content: 'A rule' },
      { path: '/project/.ruler/b.md', content: 'B rule' },
    ];
    jest.spyOn(process, 'cwd').mockReturnValue('/project');
    const result = concatenateRules(files);
    expect(result).toContain('Source: .ruler/a.md');
    expect(result).toContain('A rule');
    expect(result).toContain('Source: .ruler/b.md');
    expect(result).toContain('B rule');
  });
});
</file>

<file path="tests/unit/mcp/OpenHandsMcp.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import TOML from '@iarna/toml';
import { propagateMcpToOpenHands } from '../../../src/mcp/propagateOpenHandsMcp';
describe('propagateMcpToOpenHands', () => {
  let tmpDir: string;
  let rulerMcpPath: string;
  let openHandsConfigPath: string;
  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'oh-mcp-test-'));
    rulerMcpPath = path.join(tmpDir, 'ruler-mcp.json');
    openHandsConfigPath = path.join(tmpDir, 'config.toml');
  });
  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  it('should create a new config.toml with stdio_servers', async () => {
    const rulerMcp = {
      mcpServers: { fetch: { command: 'uvx', args: ['mcp-fetch'] } },
    };
    await fs.writeFile(rulerMcpPath, JSON.stringify(rulerMcp));
    await propagateMcpToOpenHands(rulerMcpPath, openHandsConfigPath);
    const content = await fs.readFile(openHandsConfigPath, 'utf8');
    const parsed = TOML.parse(content);
    expect(parsed.mcp).toBeDefined();
    const mcp: any = parsed.mcp;
    expect(mcp.stdio_servers).toHaveLength(1);
    expect(mcp.stdio_servers[0]).toEqual({
      name: 'fetch',
      command: 'uvx',
      args: ['mcp-fetch'],
    });
  });
  it('should merge servers into an existing config.toml', async () => {
    const rulerMcp = {
      mcpServers: { git: { command: 'npx', args: ['mcp-git'] } },
    };
    await fs.writeFile(rulerMcpPath, JSON.stringify(rulerMcp));
    const existingToml = `
[mcp]
stdio_servers = [
  { name = "fs", command = "npx", args = ["mcp-fs"] }
]
    `;
    await fs.writeFile(openHandsConfigPath, existingToml);
    await propagateMcpToOpenHands(rulerMcpPath, openHandsConfigPath);
    const content = await fs.readFile(openHandsConfigPath, 'utf8');
    const parsed = TOML.parse(content);
    const mcp: any = parsed.mcp;
    expect(mcp.stdio_servers).toHaveLength(2);
    expect(mcp.stdio_servers).toContainEqual({
      name: 'fs',
      command: 'npx',
      args: ['mcp-fs'],
    });
    expect(mcp.stdio_servers).toContainEqual({
      name: 'git',
      command: 'npx',
      args: ['mcp-git'],
    });
  });
  it('should not add duplicate servers', async () => {
    const rulerMcp = {
      mcpServers: { fs: { command: 'uvx', args: ['mcp-fs-new'] } },
    };
    await fs.writeFile(rulerMcpPath, JSON.stringify(rulerMcp));
    const existingToml = `
[mcp]
stdio_servers = [
  { name = "fs", command = "npx", args = ["mcp-fs-old"] }
]
    `;
    await fs.writeFile(openHandsConfigPath, existingToml);
    await propagateMcpToOpenHands(rulerMcpPath, openHandsConfigPath);
    const content = await fs.readFile(openHandsConfigPath, 'utf8');
    const parsed = TOML.parse(content);
    const mcp: any = parsed.mcp;
    expect(mcp.stdio_servers).toHaveLength(1);
    // The existing server should be overwritten by the new one from ruler
    expect(mcp.stdio_servers[0]).toEqual({
      name: 'fs',
      command: 'uvx',
      args: ['mcp-fs-new'],
    });
  });
  it('should propagate env variables for stdio servers', async () => {
    const serverEnv = { TEST_VAR: 'value', ANOTHER: '123' };
    const rulerMcp = {
      mcpServers: {
        fetch: { command: 'uvx', args: ['mcp-fetch'], env: serverEnv },
      },
    };
    await fs.writeFile(rulerMcpPath, JSON.stringify(rulerMcp));
    await propagateMcpToOpenHands(rulerMcpPath, openHandsConfigPath);
    const contentWithEnv = await fs.readFile(openHandsConfigPath, 'utf8');
    const parsedWithEnv: any = TOML.parse(contentWithEnv);
    expect(parsedWithEnv.mcp.stdio_servers).toHaveLength(1);
    expect(parsedWithEnv.mcp.stdio_servers[0]).toEqual(
      expect.objectContaining({ env: serverEnv }),
    );
  });
});
</file>

<file path="tests/agent-specific-disable.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { execSync } from 'child_process';
describe('agent-specific-disable', () => {
  let tmpDir: string;
  let rulerDir: string;
  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-mcp-'));
    rulerDir = path.join(tmpDir, '.ruler');
    await fs.mkdir(rulerDir, { recursive: true });
    const mcp = { mcpServers: { foo: { url: 'http://foo.com' } } };
    await fs.writeFile(
      path.join(rulerDir, 'mcp.json'),
      JSON.stringify(mcp, null, 2) + '\n',
    );
    const vscodeDir = path.join(tmpDir, '.vscode');
    await fs.mkdir(vscodeDir, { recursive: true });
    const nativeVs = { servers: { bar: { url: 'http://bar.com' } } };
    await fs.writeFile(
      path.join(vscodeDir, 'mcp.json'),
      JSON.stringify(nativeVs, null, 2) + '\n',
    );
    const cursorDir = path.join(tmpDir, '.cursor');
    await fs.mkdir(cursorDir, { recursive: true });
    const nativeCur = { mcpServers: { baz: { url: 'http://baz.com' } } };
    await fs.writeFile(
      path.join(cursorDir, 'mcp.json'),
      JSON.stringify(nativeCur, null, 2) + '\n',
    );
    const toml = `[mcp]
enabled = true
[agents.Cursor.mcp]
enabled = false
`;
    await fs.writeFile(path.join(rulerDir, 'ruler.toml'), toml);
  });
  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  it('skips disabled agent but merges others', async () => {
    execSync('npm run build', { stdio: 'inherit' });
    execSync(`node dist/cli/index.js apply --project-root ${tmpDir}`, {
      stdio: 'inherit',
    });
    const copilot = JSON.parse(
      await fs.readFile(path.join(tmpDir, '.vscode', 'mcp.json'), 'utf8'),
    );
    expect(Object.keys(copilot.servers).sort()).toEqual(['bar', 'foo']);
    const cursor = JSON.parse(
      await fs.readFile(path.join(tmpDir, '.cursor', 'mcp.json'), 'utf8'),
    );
    expect(Object.keys(cursor.mcpServers).sort()).toEqual(['baz']);
  });
});
</file>

<file path="tests/apply-mcp.disable.toml.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { execSync } from 'child_process';
describe('apply-mcp.disable.toml', () => {
  let tmpDir: string;
  let rulerDir: string;
  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-mcp-'));
    rulerDir = path.join(tmpDir, '.ruler');
    await fs.mkdir(rulerDir, { recursive: true });
    const mcp = { mcpServers: { foo: { url: 'http://foo.com' } } };
    await fs.writeFile(
      path.join(rulerDir, 'mcp.json'),
      JSON.stringify(mcp, null, 2) + '\n',
    );
    const vscodeDir = path.join(tmpDir, '.vscode');
    await fs.mkdir(vscodeDir, { recursive: true });
    const native = { mcpServers: { bar: { url: 'http://bar.com' } } };
    const nativePath = path.join(vscodeDir, 'mcp.json');
    await fs.writeFile(nativePath, JSON.stringify(native, null, 2) + '\n');
    const toml = `[mcp]
enabled = false
`;
    await fs.writeFile(path.join(rulerDir, 'ruler.toml'), toml);
  });
  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  it('does not touch native config when [mcp] enabled=false', async () => {
    const nativePath = path.join(tmpDir, '.vscode', 'mcp.json');
    const before = await fs.readFile(nativePath, 'utf8');
    execSync('npm run build', { stdio: 'inherit' });
    execSync(`node dist/cli/index.js apply --project-root ${tmpDir}`, {
      stdio: 'inherit',
    });
    const after = await fs.readFile(nativePath, 'utf8');
    expect(after).toEqual(before);
  });
});
</file>

<file path="tests/apply-mcp.merge.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { execSync } from 'child_process';
describe('apply-mcp.merge', () => {
  let tmpDir: string;
  let rulerDir: string;
  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-mcp-'));
    rulerDir = path.join(tmpDir, '.ruler');
    await fs.mkdir(rulerDir, { recursive: true });
    const mcp = { mcpServers: { foo: { url: 'http://foo.com' } } };
    await fs.writeFile(
      path.join(rulerDir, 'mcp.json'),
      JSON.stringify(mcp, null, 2) + '\n',
    );
    const vscodeDir = path.join(tmpDir, '.vscode');
    await fs.mkdir(vscodeDir, { recursive: true });
    const native = { servers: { bar: { url: 'http://bar.com' } } };
    await fs.writeFile(
      path.join(vscodeDir, 'mcp.json'),
      JSON.stringify(native, null, 2) + '\n',
    );
  });
  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  it('merges servers from .ruler/mcp.json and existing native config', async () => {
    execSync('npm run build', { stdio: 'inherit' });
    execSync(`node dist/cli/index.js apply --project-root ${tmpDir}`, {
      stdio: 'inherit',
    });
    const resultText = await fs.readFile(
      path.join(tmpDir, '.vscode', 'mcp.json'),
      'utf8',
    );
    const result = JSON.parse(resultText);
    expect(Object.keys(result.servers).sort()).toEqual(['bar', 'foo']);
  });
});
</file>

<file path="tests/apply-mcp.overwrite.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { execSync } from 'child_process';
describe('apply-mcp.overwrite', () => {
  let tmpDir: string;
  let rulerDir: string;
  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-mcp-'));
    rulerDir = path.join(tmpDir, '.ruler');
    await fs.mkdir(rulerDir, { recursive: true });
    const mcp = { mcpServers: { foo: { url: 'http://foo.com' } } };
    await fs.writeFile(
      path.join(rulerDir, 'mcp.json'),
      JSON.stringify(mcp, null, 2) + '\n',
    );
    const vscodeDir = path.join(tmpDir, '.vscode');
    await fs.mkdir(vscodeDir, { recursive: true });
    const native = { servers: { bar: { url: 'http://bar.com' } } };
    await fs.writeFile(
      path.join(vscodeDir, 'mcp.json'),
      JSON.stringify(native, null, 2) + '\n',
    );
  });
  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  it('overwrites existing native config when --mcp-overwrite is used', async () => {
    execSync('npm run build', { stdio: 'inherit' });
    execSync(
      `node dist/cli/index.js apply --project-root ${tmpDir} --mcp-overwrite`,
      { stdio: 'inherit' },
    );
    const resultText = await fs.readFile(
      path.join(tmpDir, '.vscode', 'mcp.json'),
      'utf8',
    );
    const result = JSON.parse(resultText);
    expect(Object.keys(result.servers).sort()).toEqual(['foo']);
  });
});
</file>

<file path="tests/cli-no-mcp.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { execSync } from 'child_process';
describe('cli-no-mcp', () => {
  let tmpDir: string;
  let rulerDir: string;
  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-mcp-'));
    rulerDir = path.join(tmpDir, '.ruler');
    await fs.mkdir(rulerDir, { recursive: true });
    const mcp = { mcpServers: { foo: { url: 'http://foo.com' } } };
    await fs.writeFile(
      path.join(rulerDir, 'mcp.json'),
      JSON.stringify(mcp, null, 2) + '\n',
    );
    const vscodeDir = path.join(tmpDir, '.vscode');
    await fs.mkdir(vscodeDir, { recursive: true });
    const native = { mcpServers: { bar: { url: 'http://bar.com' } } };
    const nativePath = path.join(vscodeDir, 'mcp.json');
    await fs.writeFile(nativePath, JSON.stringify(native, null, 2) + '\n');
  });
  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  it('does not apply MCP when --no-mcp is used', async () => {
    const nativePath = path.join(tmpDir, '.vscode', 'mcp.json');
    const before = await fs.readFile(nativePath, 'utf8');
    execSync('npm run build', { stdio: 'inherit' });
    execSync(
      `node dist/cli/index.js apply --project-root ${tmpDir} --no-mcp`,
      { stdio: 'inherit' },
    );
    const after = await fs.readFile(nativePath, 'utf8');
    expect(after).toEqual(before);
  });
});
</file>

<file path="tests/mcp-key-overwrite.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { execSync } from 'child_process';
describe('mcp-key-overwrite', () => {
  let tmpDir: string;
  let rulerDir: string;
  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-mcp-overwrite-'));
    rulerDir = path.join(tmpDir, '.ruler');
    await fs.mkdir(rulerDir, { recursive: true });
    // Create ruler MCP config
    const rulerMcp = { mcpServers: { ruler_server: { url: 'http://ruler.com' } } };
    await fs.writeFile(
      path.join(rulerDir, 'mcp.json'),
      JSON.stringify(rulerMcp, null, 2) + '\n',
    );
    // Create .vscode directory with existing Copilot MCP config using 'servers' key
    const vscodeDir = path.join(tmpDir, '.vscode');
    await fs.mkdir(vscodeDir, { recursive: true });
    const copilotNative = { servers: { native_copilot_server: { url: 'http://copilot.com' } } };
    await fs.writeFile(
      path.join(vscodeDir, 'mcp.json'),
      JSON.stringify(copilotNative, null, 2) + '\n',
    );
    // Create .cursor directory with existing Cursor MCP config using 'mcpServers' key
    const cursorDir = path.join(tmpDir, '.cursor');
    await fs.mkdir(cursorDir, { recursive: true });
    const cursorNative = { mcpServers: { native_cursor_server: { url: 'http://cursor.com' } } };
    await fs.writeFile(
      path.join(cursorDir, 'mcp.json'),
      JSON.stringify(cursorNative, null, 2) + '\n',
    );
  });
  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  it('should overwrite with correct keys for different agents', async () => {
    execSync('npm run build', { stdio: 'inherit' });
    execSync(`node dist/cli/index.js apply --project-root ${tmpDir} --agents copilot,cursor --mcp-overwrite`, {
      stdio: 'inherit',
    });
    // Verify Copilot MCP config was overwritten and uses 'servers' key
    const copilotResultText = await fs.readFile(
      path.join(tmpDir, '.vscode', 'mcp.json'),
      'utf8',
    );
    const copilotResult = JSON.parse(copilotResultText);
    // Should have 'servers' key, not 'mcpServers'
    expect(copilotResult.servers).toBeDefined();
    expect(copilotResult.mcpServers).toBeUndefined();
    // Should contain only ruler server (overwrite should remove native)
    expect(Object.keys(copilotResult.servers)).toEqual(['ruler_server']);
    // Verify Cursor MCP config was overwritten and uses 'mcpServers' key
    const cursorResultText = await fs.readFile(
      path.join(tmpDir, '.cursor', 'mcp.json'),
      'utf8',
    );
    const cursorResult = JSON.parse(cursorResultText);
    // Should have 'mcpServers' key
    expect(cursorResult.mcpServers).toBeDefined();
    // Should contain only ruler server (overwrite should remove native)
    expect(Object.keys(cursorResult.mcpServers)).toEqual(['ruler_server']);
  });
});
</file>

<file path="tests/mcp-key-per-agent.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { execSync } from 'child_process';
describe('mcp-key-per-agent', () => {
  let tmpDir: string;
  let rulerDir: string;
  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-mcp-key-'));
    rulerDir = path.join(tmpDir, '.ruler');
    await fs.mkdir(rulerDir, { recursive: true });
    // Create ruler MCP config
    const rulerMcp = { mcpServers: { ruler_server: { url: 'http://ruler.com' } } };
    await fs.writeFile(
      path.join(rulerDir, 'mcp.json'),
      JSON.stringify(rulerMcp, null, 2) + '\n',
    );
    // Create .vscode directory with existing Copilot MCP config using 'servers' key
    const vscodeDir = path.join(tmpDir, '.vscode');
    await fs.mkdir(vscodeDir, { recursive: true });
    const copilotNative = { servers: { native_copilot_server: { url: 'http://copilot.com' } } };
    await fs.writeFile(
      path.join(vscodeDir, 'mcp.json'),
      JSON.stringify(copilotNative, null, 2) + '\n',
    );
    // Create .cursor directory with existing Cursor MCP config using 'mcpServers' key
    const cursorDir = path.join(tmpDir, '.cursor');
    await fs.mkdir(cursorDir, { recursive: true });
    const cursorNative = { mcpServers: { native_cursor_server: { url: 'http://cursor.com' } } };
    await fs.writeFile(
      path.join(cursorDir, 'mcp.json'),
      JSON.stringify(cursorNative, null, 2) + '\n',
    );
  });
  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  it('should use "servers" key for Copilot and "mcpServers" key for Cursor', async () => {
    execSync('npm run build', { stdio: 'inherit' });
    execSync(`node dist/cli/index.js apply --project-root ${tmpDir} --agents copilot,cursor`, {
      stdio: 'inherit',
    });
    // Verify Copilot MCP config uses 'servers' key
    const copilotResultText = await fs.readFile(
      path.join(tmpDir, '.vscode', 'mcp.json'),
      'utf8',
    );
    const copilotResult = JSON.parse(copilotResultText);
    // Should have 'servers' key, not 'mcpServers'
    expect(copilotResult.servers).toBeDefined();
    expect(copilotResult.mcpServers).toBeUndefined();
    // Should contain both native and ruler servers
    expect(Object.keys(copilotResult.servers).sort()).toEqual(['native_copilot_server', 'ruler_server']);
    // Verify Cursor MCP config uses 'mcpServers' key
    const cursorResultText = await fs.readFile(
      path.join(tmpDir, '.cursor', 'mcp.json'),
      'utf8',
    );
    const cursorResult = JSON.parse(cursorResultText);
    // Should have 'mcpServers' key
    expect(cursorResult.mcpServers).toBeDefined();
    // Should contain both native and ruler servers
    expect(Object.keys(cursorResult.mcpServers).sort()).toEqual(['native_cursor_server', 'ruler_server']);
  });
});
</file>

<file path=".cursorindexingignore">
# Don't index SpecStory auto-save files, but allow explicit context inclusion via @ references
.specstory/**
</file>

<file path=".eslintignore">
dist
node_modules
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
issue-body.md
</file>

<file path=".prettierignore">
dist
node_modules
</file>

<file path="jest.config.js">
/** @type {import('ts-jest/dist/types').InitialOptionsTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/tests/**/*.{test,spec}.ts', '**/*.test.ts'],
  moduleFileExtensions: ['ts', 'js', 'json', 'node'],
  coverageDirectory: 'coverage',
};
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Eleanor Berger

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "es2020",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "libReplacement": true,                           /* Enable lib replacement. */
    // "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

    /* Modules */
    "module": "commonjs",                                /* Specify what module code is generated. */
    "rootDir": "src",                                    /* Specify the root folder within your source files. */
    // "moduleResolution": "node10",                     /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */
    // "rewriteRelativeImportExtensions": true,          /* Rewrite '.ts', '.tsx', '.mts', and '.cts' file extensions in relative import paths to their JavaScript equivalent in output files. */
    // "resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */
    // "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */
    // "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */
    // "noUncheckedSideEffectImports": true,             /* Check side effect imports. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    "outDir": "dist",                                    /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */
    // "isolatedDeclarations": true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */
    // "erasableSyntaxOnly": true,                       /* Do not allow runtime constructs that are not part of ECMAScript. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */

    /* Type Checking */
    "strict": true,                                      /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "strictBuiltinIteratorReturn": true,              /* Built-in iterators are instantiated with a 'TReturn' type of 'undefined' instead of 'any'. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */
  },
"include": ["src"],
"exclude": ["node_modules", "dist", "tests"]
}
</file>

<file path="src/agents/AiderAgent.ts">
import * as path from 'path';
import { IAgent, IAgentConfig } from './IAgent';
import { backupFile, writeGeneratedFile } from '../core/FileSystemUtils';
import * as fs from 'fs/promises';
import * as yaml from 'js-yaml';
/**
 * Aider agent adapter (stub implementation).
 */
export class AiderAgent implements IAgent {
  getIdentifier(): string {
    return 'aider';
  }
  getName(): string {
    return 'Aider';
  }
  async applyRulerConfig(
    concatenatedRules: string,
    projectRoot: string,
    rulerMcpJson: Record<string, unknown> | null, // eslint-disable-line @typescript-eslint/no-unused-vars
    agentConfig?: IAgentConfig,
  ): Promise<void> {
    const mdPath =
      agentConfig?.outputPathInstructions ??
      this.getDefaultOutputPath(projectRoot).instructions;
    await backupFile(mdPath);
    await writeGeneratedFile(mdPath, concatenatedRules);
    const cfgPath =
      agentConfig?.outputPathConfig ??
      this.getDefaultOutputPath(projectRoot).config;
    interface AiderConfig {
      read?: string[];
      [key: string]: unknown;
    }
    let doc: AiderConfig = {} as AiderConfig;
    try {
      await fs.access(cfgPath);
      await backupFile(cfgPath);
      const raw = await fs.readFile(cfgPath, 'utf8');
      doc = (yaml.load(raw) || {}) as AiderConfig;
    } catch {
      doc = {} as AiderConfig;
    }
    if (!Array.isArray(doc.read)) {
      doc.read = [];
    }
    const name = path.basename(mdPath);
    if (!doc.read.includes(name)) {
      doc.read.push(name);
    }
    const yamlStr = yaml.dump(doc);
    await writeGeneratedFile(cfgPath, yamlStr);
  }
  getDefaultOutputPath(projectRoot: string): Record<string, string> {
    return {
      instructions: path.join(projectRoot, 'ruler_aider_instructions.md'),
      config: path.join(projectRoot, '.aider.conf.yml'),
    };
  }
}
</file>

<file path="src/agents/ClaudeAgent.ts">
import * as path from 'path';
import { IAgent, IAgentConfig } from './IAgent';
import { backupFile, writeGeneratedFile } from '../core/FileSystemUtils';
/**
 * Claude Code agent adapter (stub implementation).
 */
export class ClaudeAgent implements IAgent {
  getIdentifier(): string {
    return 'claude';
  }
  getName(): string {
    return 'Claude Code';
  }
  async applyRulerConfig(
    concatenatedRules: string,
    projectRoot: string,
    rulerMcpJson: Record<string, unknown> | null, // eslint-disable-line @typescript-eslint/no-unused-vars
    agentConfig?: IAgentConfig,
  ): Promise<void> {
    const output =
      agentConfig?.outputPath ?? this.getDefaultOutputPath(projectRoot);
    await backupFile(output);
    await writeGeneratedFile(output, concatenatedRules);
  }
  getDefaultOutputPath(projectRoot: string): string {
    return path.join(projectRoot, 'CLAUDE.md');
  }
}
</file>

<file path="src/agents/ClineAgent.ts">
import * as path from 'path';
import { IAgent, IAgentConfig } from './IAgent';
import { backupFile, writeGeneratedFile } from '../core/FileSystemUtils';
/**
 * Cline agent adapter (stub implementation).
 */
export class ClineAgent implements IAgent {
  getIdentifier(): string {
    return 'cline';
  }
  getName(): string {
    return 'Cline';
  }
  async applyRulerConfig(
    concatenatedRules: string,
    projectRoot: string,
    rulerMcpJson: Record<string, unknown> | null, // eslint-disable-line @typescript-eslint/no-unused-vars
    agentConfig?: IAgentConfig,
  ): Promise<void> {
    const output =
      agentConfig?.outputPath ?? this.getDefaultOutputPath(projectRoot);
    await backupFile(output);
    await writeGeneratedFile(output, concatenatedRules);
  }
  getDefaultOutputPath(projectRoot: string): string {
    return path.join(projectRoot, '.clinerules');
  }
}
</file>

<file path="src/agents/CodexCliAgent.ts">
import * as path from 'path';
import { IAgent, IAgentConfig } from './IAgent';
import { backupFile, writeGeneratedFile } from '../core/FileSystemUtils';
/**
 * OpenAI Codex CLI agent adapter (stub implementation).
 */
export class CodexCliAgent implements IAgent {
  getIdentifier(): string {
    return 'codex';
  }
  getName(): string {
    return 'OpenAI Codex CLI';
  }
  async applyRulerConfig(
    concatenatedRules: string,
    projectRoot: string,
    rulerMcpJson: Record<string, unknown> | null, // eslint-disable-line @typescript-eslint/no-unused-vars
    agentConfig?: IAgentConfig,
  ): Promise<void> {
    const output =
      agentConfig?.outputPath ?? this.getDefaultOutputPath(projectRoot);
    await backupFile(output);
    await writeGeneratedFile(output, concatenatedRules);
  }
  getDefaultOutputPath(projectRoot: string): string {
    return path.join(projectRoot, 'AGENTS.md');
  }
}
</file>

<file path="src/agents/CopilotAgent.ts">
import * as path from 'path';
import { IAgent, IAgentConfig } from './IAgent';
import {
  backupFile,
  writeGeneratedFile,
  ensureDirExists,
} from '../core/FileSystemUtils';
/**
 * GitHub Copilot agent adapter (stub implementation).
 */
export class CopilotAgent implements IAgent {
  getIdentifier(): string {
    return 'copilot';
  }
  getName(): string {
    return 'GitHub Copilot';
  }
  async applyRulerConfig(
    concatenatedRules: string,
    projectRoot: string,
    rulerMcpJson: Record<string, unknown> | null, // eslint-disable-line @typescript-eslint/no-unused-vars
    agentConfig?: IAgentConfig,
  ): Promise<void> {
    const output =
      agentConfig?.outputPath ?? this.getDefaultOutputPath(projectRoot);
    await ensureDirExists(path.dirname(output));
    await backupFile(output);
    await writeGeneratedFile(output, concatenatedRules);
  }
  getDefaultOutputPath(projectRoot: string): string {
    return path.join(projectRoot, '.github', 'copilot-instructions.md');
  }
  getMcpServerKey(): string {
    return 'servers';
  }
}
</file>

<file path="src/agents/CursorAgent.ts">
import * as path from 'path';
import { IAgent, IAgentConfig } from './IAgent';
import {
  backupFile,
  writeGeneratedFile,
  ensureDirExists,
} from '../core/FileSystemUtils';
/**
 * Cursor agent adapter (stub implementation).
 */
export class CursorAgent implements IAgent {
  getIdentifier(): string {
    return 'cursor';
  }
  getName(): string {
    return 'Cursor';
  }
  async applyRulerConfig(
    concatenatedRules: string,
    projectRoot: string,
    rulerMcpJson: Record<string, unknown> | null, // eslint-disable-line @typescript-eslint/no-unused-vars
    agentConfig?: IAgentConfig,
  ): Promise<void> {
    const output =
      agentConfig?.outputPath ?? this.getDefaultOutputPath(projectRoot);
    await ensureDirExists(path.dirname(output));
    await backupFile(output);
    await writeGeneratedFile(output, concatenatedRules);
  }
  getDefaultOutputPath(projectRoot: string): string {
    return path.join(
      projectRoot,
      '.cursor',
      'rules',
      'ruler_cursor_instructions.mdc',
    );
  }
}
</file>

<file path="src/agents/FirebaseAgent.ts">
import * as path from 'path';
import { IAgent, IAgentConfig } from './IAgent';
import { backupFile, writeGeneratedFile } from '../core/FileSystemUtils';
/**
 * Firebase Studio agent adapter.
 */
export class FirebaseAgent implements IAgent {
  getIdentifier(): string {
    return 'firebase';
  }
  getName(): string {
    return 'Firebase Studio';
  }
  async applyRulerConfig(
    concatenatedRules: string,
    projectRoot: string,
    rulerMcpJson: Record<string, unknown> | null, // eslint-disable-line @typescript-eslint/no-unused-vars
    agentConfig?: IAgentConfig,
  ): Promise<void> {
    const output =
      agentConfig?.outputPath ?? this.getDefaultOutputPath(projectRoot);
    await backupFile(output);
    await writeGeneratedFile(output, concatenatedRules);
  }
  getDefaultOutputPath(projectRoot: string): string {
    return path.join(projectRoot, '.idx', 'airules.md');
  }
}
</file>

<file path="src/agents/IAgent.ts">
/**
 * Interface defining an AI agent configuration adapter.
 */
export interface IAgentConfig {
  /** Explicit enable/disable agent */
  enabled?: boolean;
  /** Override for primary output path */
  outputPath?: string;
  /** Override for Aider instruction file path */
  outputPathInstructions?: string;
  /** Override for Aider config file path */
  outputPathConfig?: string;
  mcp?: {
    enabled?: boolean;
    strategy?: 'merge' | 'overwrite';
  };
}
export interface IAgent {
  /**
   * Returns the lowercase identifier of the agent (e.g., "copilot", "claude", "aider").
   */
  getIdentifier(): string;
  /**
   * Returns the display name of the agent.
   */
  getName(): string;
  /**
   * Applies the concatenated ruler rules to the agent's configuration.
   * @param concatenatedRules The combined rules text
   * @param projectRoot The root directory of the project
   */
  applyRulerConfig(
    concatenatedRules: string,
    projectRoot: string,
    rulerMcpJson: Record<string, unknown> | null,
    agentConfig?: IAgentConfig,
  ): Promise<void>;
  /**
   * Returns the default output path(s) for this agent given the project root.
   */
  getDefaultOutputPath(projectRoot: string): string | Record<string, string>;
  /**
   * Returns the specific key to be used for the server object in MCP JSON.
   * Defaults to 'mcpServers' if not implemented.
   */
  getMcpServerKey?(): string;
}
</file>

<file path="src/agents/OpenHandsAgent.ts">
import * as path from 'path';
import { IAgent, IAgentConfig } from './IAgent';
import {
  backupFile,
  writeGeneratedFile,
  ensureDirExists,
} from '../core/FileSystemUtils';
export class OpenHandsAgent implements IAgent {
  getIdentifier(): string {
    return 'openhands';
  }
  getName(): string {
    return 'Open Hands';
  }
  async applyRulerConfig(
    concatenatedRules: string,
    projectRoot: string,
    rulerMcpJson: Record<string, unknown> | null, // eslint-disable-line @typescript-eslint/no-unused-vars
    agentConfig?: IAgentConfig,
  ): Promise<void> {
    const output =
      agentConfig?.outputPath ?? this.getDefaultOutputPath(projectRoot);
    await ensureDirExists(path.dirname(output));
    await backupFile(output);
    await writeGeneratedFile(output, concatenatedRules);
  }
  getDefaultOutputPath(projectRoot: string): string {
    return path.join(projectRoot, '.openhands', 'microagents', 'repo.md');
  }
}
</file>

<file path="src/agents/WindsurfAgent.ts">
import * as path from 'path';
import { IAgent, IAgentConfig } from './IAgent';
import {
  backupFile,
  writeGeneratedFile,
  ensureDirExists,
} from '../core/FileSystemUtils';
/**
 * Windsurf agent adapter (stub implementation).
 */
export class WindsurfAgent implements IAgent {
  getIdentifier(): string {
    return 'windsurf';
  }
  getName(): string {
    return 'Windsurf';
  }
  async applyRulerConfig(
    concatenatedRules: string,
    projectRoot: string,
    rulerMcpJson: Record<string, unknown> | null, // eslint-disable-line @typescript-eslint/no-unused-vars
    agentConfig?: IAgentConfig,
  ): Promise<void> {
    const output =
      agentConfig?.outputPath ?? this.getDefaultOutputPath(projectRoot);
    await ensureDirExists(path.dirname(output));
    await backupFile(output);
    await writeGeneratedFile(output, concatenatedRules);
  }
  getDefaultOutputPath(projectRoot: string): string {
    return path.join(
      projectRoot,
      '.windsurf',
      'rules',
      'ruler_windsurf_instructions.md',
    );
  }
}
</file>

<file path="src/cli/commands.ts">
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import { applyAllAgentConfigs } from '../lib';
import * as path from 'path';
import { promises as fs } from 'fs';
import { ERROR_PREFIX } from '../constants';
/**
 * Sets up and parses CLI commands.
 */
export function run(): void {
  yargs(hideBin(process.argv))
    .scriptName('ruler')
    .usage('$0 <command> [options]')
    .command(
      'apply',
      'Apply ruler configurations to supported AI agents',
      (y) => {
        y.option('project-root', {
          type: 'string',
          description: 'Project root directory',
          default: process.cwd(),
        });
        y.option('agents', {
          type: 'string',
          description:
            'Comma-separated list of agent identifiers: copilot, claude, codex, cursor, windsurf, cline, aider, firebase, gemini-cli',
        });
        y.option('config', {
          type: 'string',
          description: 'Path to TOML configuration file',
        });
        y.option('mcp', {
          type: 'boolean',
          description: 'Enable or disable applying MCP server config',
          default: true,
        });
        y.alias('mcp', 'with-mcp');
        y.option('mcp-overwrite', {
          type: 'boolean',
          description: 'Replace (not merge) the native MCP config(s)',
          default: false,
        });
        y.option('gitignore', {
          type: 'boolean',
          description:
            'Enable/disable automatic .gitignore updates (default: enabled)',
        });
        y.option('verbose', {
          type: 'boolean',
          description: 'Enable verbose logging',
          default: false,
        });
        y.alias('verbose', 'v');
        y.option('dry-run', {
          type: 'boolean',
          description: 'Preview changes without writing files',
          default: false,
        });
      },
      async (argv) => {
        const projectRoot = argv['project-root'] as string;
        const agents = argv.agents
          ? (argv.agents as string).split(',').map((a) => a.trim())
          : undefined;
        const configPath = argv.config as string | undefined;
        const mcpEnabled = argv.mcp as boolean;
        const mcpStrategy = (argv['mcp-overwrite'] as boolean)
          ? 'overwrite'
          : undefined;
        const verbose = argv.verbose as boolean;
        const dryRun = argv['dry-run'] as boolean;
        // Determine gitignore preference: CLI > TOML > Default (enabled)
        // yargs handles --no-gitignore by setting gitignore to false
        let gitignorePreference: boolean | undefined;
        if (argv.gitignore !== undefined) {
          gitignorePreference = argv.gitignore as boolean;
        } else {
          gitignorePreference = undefined; // Let TOML/default decide
        }
        try {
          await applyAllAgentConfigs(
            projectRoot,
            agents,
            configPath,
            mcpEnabled,
            mcpStrategy,
            gitignorePreference,
            verbose,
            dryRun,
          );
          console.log('Ruler apply completed successfully.');
        } catch (err: unknown) {
          const message = err instanceof Error ? err.message : String(err);
          console.error(`${ERROR_PREFIX} ${message}`);
          process.exit(1);
        }
      },
    )
    .command(
      'init',
      'Scaffold a .ruler directory with default files',
      (y) => {
        y.option('project-root', {
          type: 'string',
          description: 'Project root directory',
          default: process.cwd(),
        });
      },
      async (argv) => {
        const projectRoot = argv['project-root'] as string;
        const rulerDir = path.join(projectRoot, '.ruler');
        await fs.mkdir(rulerDir, { recursive: true });
        const instructionsPath = path.join(rulerDir, 'instructions.md');
        const tomlPath = path.join(rulerDir, 'ruler.toml');
        const exists = async (p: string) => {
          try {
            await fs.access(p);
            return true;
          } catch {
            return false;
          }
        };
        const DEFAULT_INSTRUCTIONS = `# Ruler Instructions
These are your centralised AI agent instructions.
Add your coding guidelines, style guides, and other project-specific context here.
Ruler will concatenate all .md files in this directory (and its subdirectories)
and apply them to your configured AI coding agents.
`;
        const DEFAULT_TOML = `# Ruler Configuration File
# See https://ai.intellectronica.net/ruler for documentation.
# To specify which agents are active by default when --agents is not used,
# uncomment and populate the following line. If omitted, all agents are active.
# default_agents = ["copilot", "claude"]
# --- Agent Specific Configurations ---
# You can enable/disable agents and override their default output paths here.
# Use lowercase agent identifiers: copilot, claude, codex, cursor, windsurf, cline, aider
# [agents.copilot]
# enabled = true
# output_path = ".github/copilot-instructions.md"
# [agents.claude]
# enabled = true
# output_path = "CLAUDE.md"
# [agents.codex]
# enabled = true
# output_path = "AGENTS.md"
# [agents.cursor]
# enabled = true
# output_path = ".cursor/rules/ruler_cursor_instructions.mdc"
# [agents.windsurf]
# enabled = true
# output_path = ".windsurf/rules/ruler_windsurf_instructions.md"
# [agents.cline]
# enabled = true
# output_path = ".clinerules"
# [agents.aider]
# enabled = true
# output_path_instructions = "ruler_aider_instructions.md"
# output_path_config = ".aider.conf.yml"
# [agents.firebase]
# enabled = true
# output_path = ".idx/airules.md"
# [agents.gemini-cli]
# enabled = true
`;
        if (!(await exists(instructionsPath))) {
          await fs.writeFile(instructionsPath, DEFAULT_INSTRUCTIONS);
          console.log(`[ruler] Created ${instructionsPath}`);
        } else {
          console.log(`[ruler] instructions.md already exists, skipping`);
        }
        if (!(await exists(tomlPath))) {
          await fs.writeFile(tomlPath, DEFAULT_TOML);
          console.log(`[ruler] Created ${tomlPath}`);
        } else {
          console.log(`[ruler] ruler.toml already exists, skipping`);
        }
        const mcpPath = path.join(rulerDir, 'mcp.json');
        const DEFAULT_MCP_JSON = `{
  "mcpServers": {
    "example": {
      "url": "https://mcp.example.com"
    }
  }
}`;
        if (!(await exists(mcpPath))) {
          await fs.writeFile(mcpPath, DEFAULT_MCP_JSON);
          console.log(`[ruler] Created ${mcpPath}`);
        } else {
          console.log(`[ruler] mcp.json already exists, skipping`);
        }
      },
    )
    .demandCommand(1, 'You need to specify a command')
    .help()
    .strict()
    .parse();
}
</file>

<file path="tests/unit/agents/AgentAdapters.test.ts">
import { promises as fs } from 'fs';
import * as path from 'path';
import os from 'os';
import yaml from 'js-yaml';
import { CopilotAgent } from '../../../src/agents/CopilotAgent';
import { ClaudeAgent } from '../../../src/agents/ClaudeAgent';
import { CodexCliAgent } from '../../../src/agents/CodexCliAgent';
import { CursorAgent } from '../../../src/agents/CursorAgent';
import { WindsurfAgent } from '../../../src/agents/WindsurfAgent';
import { ClineAgent } from '../../../src/agents/ClineAgent';
import { AiderAgent } from '../../../src/agents/AiderAgent';
import { FirebaseAgent } from '../../../src/agents/FirebaseAgent';
describe('Agent Adapters', () => {
  let tmpDir: string;
  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-agent-'));
  });
  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  describe('CopilotAgent', () => {
  it('backs up and writes copilot-instructions.md', async () => {
      const agent = new CopilotAgent();
      const githubDir = path.join(tmpDir, '.github');
      await fs.mkdir(githubDir, { recursive: true });
      const target = path.join(githubDir, 'copilot-instructions.md');
      await fs.writeFile(target, 'old copilot');
      await agent.applyRulerConfig('new copilot', tmpDir, null);
      const backup = await fs.readFile(`${target}.bak`, 'utf8');
      const content = await fs.readFile(target, 'utf8');
      expect(backup).toBe('old copilot');
      expect(content).toBe('new copilot');
    });
  });
  it('uses custom outputPath when provided', async () => {
    const agent = new CopilotAgent();
    const custom = path.join(tmpDir, 'custom_copilot.md');
    await fs.mkdir(path.dirname(custom), { recursive: true });
    await agent.applyRulerConfig('custom data', tmpDir, null, { outputPath: custom });
    expect(await fs.readFile(custom, 'utf8')).toBe('custom data');
  });
  describe('ClaudeAgent', () => {
  it('backs up and writes CLAUDE.md', async () => {
      const agent = new ClaudeAgent();
      const target = path.join(tmpDir, 'CLAUDE.md');
      await fs.writeFile(target, 'old claude');
      await agent.applyRulerConfig('new claude', tmpDir, null);
      expect(await fs.readFile(`${target}.bak`, 'utf8')).toBe('old claude');
      expect(await fs.readFile(target, 'utf8')).toBe('new claude');
    });
  });
  it('uses custom outputPath when provided', async () => {
    const agent = new ClaudeAgent();
    const custom = path.join(tmpDir, 'CUSTOM_CLAUDE.md');
    await fs.mkdir(path.dirname(custom), { recursive: true });
    await agent.applyRulerConfig('x', tmpDir, null, { outputPath: custom });
    expect(await fs.readFile(custom, 'utf8')).toBe('x');
  });
  describe('CodexCliAgent', () => {
  it('backs up and writes AGENTS.md', async () => {
      const agent = new CodexCliAgent();
      const target = path.join(tmpDir, 'AGENTS.md');
      await fs.writeFile(target, 'old codex');
      await agent.applyRulerConfig('new codex', tmpDir, null);
      expect(await fs.readFile(`${target}.bak`, 'utf8')).toBe('old codex');
      expect(await fs.readFile(target, 'utf8')).toBe('new codex');
    });
  });
  it('uses custom outputPath when provided', async () => {
    const agent = new CodexCliAgent();
    const custom = path.join(tmpDir, 'CUSTOM_AGENTS.md');
    await fs.mkdir(path.dirname(custom), { recursive: true });
    await agent.applyRulerConfig('y', tmpDir, null, { outputPath: custom });
    expect(await fs.readFile(custom, 'utf8')).toBe('y');
  });
  describe('CursorAgent', () => {
  it('backs up and writes ruler_cursor_instructions.mdc', async () => {
      const agent = new CursorAgent();
      const rulesDir = path.join(tmpDir, '.cursor', 'rules');
      await fs.mkdir(rulesDir, { recursive: true });
      const target = path.join(rulesDir, 'ruler_cursor_instructions.mdc');
      await fs.writeFile(target, 'old cursor');
      await agent.applyRulerConfig('new cursor', tmpDir, null);
      expect(await fs.readFile(`${target}.bak`, 'utf8')).toBe('old cursor');
      expect(await fs.readFile(target, 'utf8')).toBe('new cursor');
    });
  });
  it('uses custom outputPath when provided', async () => {
    const agent = new CursorAgent();
    const customDir = path.join(tmpDir, '.cursor', 'rules');
    await fs.mkdir(customDir, { recursive: true });
    const custom = path.join(tmpDir, 'custom_cursor.mdc');
    await fs.mkdir(path.dirname(custom), { recursive: true });
    await agent.applyRulerConfig('z', tmpDir, null, { outputPath: custom });
    expect(await fs.readFile(custom, 'utf8')).toBe('z');
  });
  describe('WindsurfAgent', () => {
  it('backs up and writes ruler_windsurf_instructions.md', async () => {
      const agent = new WindsurfAgent();
      const rulesDir = path.join(tmpDir, '.windsurf', 'rules');
      await fs.mkdir(rulesDir, { recursive: true });
      const target = path.join(rulesDir, 'ruler_windsurf_instructions.md');
      await fs.writeFile(target, 'old windsurf');
      await agent.applyRulerConfig('new windsurf', tmpDir, null);
      expect(await fs.readFile(`${target}.bak`, 'utf8')).toBe('old windsurf');
      expect(await fs.readFile(target, 'utf8')).toBe('new windsurf');
    });
  });
  it('uses custom outputPath when provided', async () => {
    const agent = new WindsurfAgent();
    const customDir = path.join(tmpDir, '.windsurf', 'rules');
    await fs.mkdir(customDir, { recursive: true });
    const custom = path.join(tmpDir, 'custom_windsurf.md');
    await fs.mkdir(path.dirname(custom), { recursive: true });
    await agent.applyRulerConfig('w', tmpDir, null, { outputPath: custom });
    expect(await fs.readFile(custom, 'utf8')).toBe('w');
  });
  describe('ClineAgent', () => {
  it('backs up and writes .clinerules', async () => {
      const agent = new ClineAgent();
      const target = path.join(tmpDir, '.clinerules');
      await fs.writeFile(target, 'old cline');
      await agent.applyRulerConfig('new cline', tmpDir, null);
      expect(await fs.readFile(`${target}.bak`, 'utf8')).toBe('old cline');
      expect(await fs.readFile(target, 'utf8')).toBe('new cline');
    });
  });
  it('uses custom outputPath when provided', async () => {
    const agent = new ClineAgent();
    const custom = path.join(tmpDir, 'custom_cline');
    await fs.mkdir(path.dirname(custom), { recursive: true });
    await agent.applyRulerConfig('c', tmpDir, null, { outputPath: custom });
    expect(await fs.readFile(custom, 'utf8')).toBe('c');
  });
  describe('AiderAgent', () => {
  it('creates and updates .aider.conf.yml', async () => {
      const agent = new AiderAgent();
      // No existing config
      await agent.applyRulerConfig('aider rules', tmpDir, null);
      const mdFile = path.join(tmpDir, 'ruler_aider_instructions.md');
      expect(await fs.readFile(mdFile, 'utf8')).toBe('aider rules');
      const cfg = yaml.load(await fs.readFile(path.join(tmpDir, '.aider.conf.yml'), 'utf8')) as any;
      expect(cfg.read).toContain('ruler_aider_instructions.md');
      // Existing config with read not array
      const cfgPath = path.join(tmpDir, '.aider.conf.yml');
      await fs.writeFile(cfgPath, 'read: outdated');
      await agent.applyRulerConfig('new aider', tmpDir, null);
      const updated = yaml.load(await fs.readFile(cfgPath, 'utf8')) as any;
      expect(Array.isArray(updated.read)).toBe(true);
      expect(updated.read).toContain('ruler_aider_instructions.md');
    });
  });
  it('uses custom outputPathInstructions when provided', async () => {
    const agent = new AiderAgent();
    const customMd = path.join(tmpDir, 'custom_aider.md');
    await fs.mkdir(path.dirname(customMd), { recursive: true });
    await agent.applyRulerConfig('aider data', tmpDir, null, { outputPathInstructions: customMd });
    expect(await fs.readFile(customMd, 'utf8')).toBe('aider data');
    const cfg = yaml.load(
      await fs.readFile(path.join(tmpDir, '.aider.conf.yml'), 'utf8'),
    ) as any;
    expect(cfg.read).toContain('custom_aider.md');
  });
  describe('FirebaseAgent', () => {
  it('backs up and writes .idx/airules.md', async () => {
      const agent = new FirebaseAgent();
      const idxDir = path.join(tmpDir, '.idx');
      await fs.mkdir(idxDir, { recursive: true });
      const target = path.join(idxDir, 'airules.md');
      await fs.writeFile(target, 'old firebase');
      await agent.applyRulerConfig('new firebase', tmpDir, null);
      expect(await fs.readFile(`${target}.bak`, 'utf8')).toBe('old firebase');
      expect(await fs.readFile(target, 'utf8')).toBe('new firebase');
    });
  });
  it('uses custom outputPath when provided', async () => {
    const agent = new FirebaseAgent();
    const custom = path.join(tmpDir, 'custom_firebase.md');
    await fs.mkdir(path.dirname(custom), { recursive: true });
    await agent.applyRulerConfig('firebase rules', tmpDir, null, { outputPath: custom });
    expect(await fs.readFile(custom, 'utf8')).toBe('firebase rules');
  });
});
</file>

<file path="tests/unit/agents/FirebaseAgent.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { FirebaseAgent } from '../../../src/agents/FirebaseAgent';
describe('FirebaseAgent', () => {
  let tmpDir: string;
  let agent: FirebaseAgent;
  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'firebase-agent-'));
    agent = new FirebaseAgent();
  });
  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  describe('agent properties', () => {
    it('returns correct identifier', () => {
      expect(agent.getIdentifier()).toBe('firebase');
    });
    it('returns correct name', () => {
      expect(agent.getName()).toBe('Firebase Studio');
    });
    it('returns correct default output path', () => {
      const expected = path.join(tmpDir, '.idx', 'airules.md');
      expect(agent.getDefaultOutputPath(tmpDir)).toBe(expected);
    });
  });
  describe('applyRulerConfig', () => {
    it('creates .idx directory and writes airules.md', async () => {
      const rules = 'Test rules for Firebase Studio';
      await agent.applyRulerConfig(rules, tmpDir, null);
      const outputPath = path.join(tmpDir, '.idx', 'airules.md');
      const content = await fs.readFile(outputPath, 'utf8');
      expect(content).toBe(rules);
    });
    it('backs up existing airules.md file', async () => {
      // Create existing file
      const idxDir = path.join(tmpDir, '.idx');
      await fs.mkdir(idxDir, { recursive: true });
      const outputPath = path.join(idxDir, 'airules.md');
      const existingContent = 'Existing Firebase rules';
      await fs.writeFile(outputPath, existingContent);
      // Apply new rules
      const newRules = 'New Firebase rules';
      await agent.applyRulerConfig(newRules, tmpDir, null);
      // Check backup was created
      const backupPath = `${outputPath}.bak`;
      const backupContent = await fs.readFile(backupPath, 'utf8');
      expect(backupContent).toBe(existingContent);
      // Check new content was written
      const content = await fs.readFile(outputPath, 'utf8');
      expect(content).toBe(newRules);
    });
    it('uses custom output path when provided', async () => {
      const rules = 'some rules';
      const customPath = path.join(tmpDir, 'custom', 'firebase-rules.md');
      await fs.mkdir(path.dirname(customPath), { recursive: true });
      await agent.applyRulerConfig(rules, tmpDir, null, { outputPath: customPath });
      const content = await fs.readFile(customPath, 'utf8');
      expect(content).toBe(rules);
    });
  });
});
</file>

<file path="tests/unit/agents/OpenHandsAgent.test.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { OpenHandsAgent } from '../../../src/agents/OpenHandsAgent';
describe('OpenHandsAgent', () => {
  let tmpDir: string;
  let agent: OpenHandsAgent;
  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'openhands-agent-'));
    agent = new OpenHandsAgent();
  });
  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });
  it('should return the correct identifier', () => {
    expect(agent.getIdentifier()).toBe('openhands');
  });
  it('should return the correct name', () => {
    expect(agent.getName()).toBe('Open Hands');
  });
  it('should return the correct default output path for instructions', () => {
    const expected = path.join(tmpDir, '.openhands', 'microagents', 'repo.md');
    expect(agent.getDefaultOutputPath(tmpDir)).toBe(expected);
  });
  it('should write instructions to the correct file', async () => {
    const rules = 'Test instructions';
    await agent.applyRulerConfig(rules, tmpDir, null);
    const outputPath = path.join(tmpDir, '.openhands', 'microagents', 'repo.md');
    const content = await fs.readFile(outputPath, 'utf8');
    expect(content).toBe(rules);
  });
});
</file>

<file path="package.json">
{
  "name": "@intellectronica/ruler",
  "version": "0.2.5",
  "description": "Ruler — apply the same rules to all coding agents",
  "main": "dist/lib.js",
  "scripts": {
    "lint": "eslint \"src/**/*.{ts,tsx}\"",
    "format": "prettier --write \"src/**/*.{ts,tsx,json,md}\"",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "build": "tsc",
    "prepare": "npm run build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/intellectronica/ruler.git"
  },
  "keywords": [
    "ai",
    "developer-tools",
    "copilot",
    "codex",
    "claude",
    "cursor",
    "aider",
    "config",
    "rules",
    "automation"
  ],
  "author": "Eleanor Berger",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/intellectronica/ruler/issues"
  },
  "homepage": "https://ai.intellectronica.net/ruler",
  "files": [
    "dist",
    "README.md",
    "LICENSE"
  ],
  "bin": {
    "ruler": "dist/cli/index.js"
  },
  "devDependencies": {
    "@types/iarna__toml": "^2.0.5",
    "@types/jest": "^29.5.14",
    "@types/js-yaml": "^4.0.9",
    "@types/node": "^22.15.24",
    "@types/yargs": "^17.0.33",
    "@typescript-eslint/eslint-plugin": "^8.32.1",
    "@typescript-eslint/parser": "^8.32.1",
    "eslint": "^8.57.1",
    "eslint-config-prettier": "^10.1.5",
    "eslint-plugin-prettier": "^5.4.0",
    "jest": "^29.7.0",
    "prettier": "^3.5.3",
    "ts-jest": "^29.3.4",
    "typescript": "^5.8.3"
  },
  "dependencies": {
    "@iarna/toml": "^2.2.5",
    "js-yaml": "^4.1.0",
    "yargs": "^17.7.2",
    "zod": "^3.25.28"
  }
}
</file>

<file path="README.md">
# Ruler: Centralise Your AI Coding Assistant Instructions

[![CI](https://github.com/intellectronica/ruler/actions/workflows/ci.yml/badge.svg)](https://github.com/intellectronica/ruler/actions/workflows/ci.yml)
[![npm version](https://badge.fury.io/js/%40intellectronica%2Fruler.svg)](https://badge.fury.io/js/%40intellectronica%2Fruler)
![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)

- **GitHub**: [intellectronica/ruler](https://github.com/intellectronica/ruler)
- **NPM**: [@intellectronica/ruler](https://www.npmjs.com/package/@intellectronica/ruler)

---

> **Beta Research Preview**
> - Please test this version carefully in your environment
> - Report issues at https://github.com/intellectronica/ruler/issues

## Why Ruler?

Managing instructions across multiple AI coding tools becomes complex as your team grows. Different agents (GitHub Copilot, Claude, Cursor, Aider, etc.) require their own configuration files, leading to:

- **Inconsistent guidance** across AI tools
- **Duplicated effort** maintaining multiple config files
- **Context drift** as project requirements evolve
- **Onboarding friction** for new AI tools

Ruler solves this by providing a **single source of truth** for all your AI agent instructions, automatically distributing them to the right configuration files.

## Core Features

- **Centralised Rule Management**: Store all AI instructions in a dedicated `.ruler/` directory using Markdown files
- **Automatic Distribution**: Ruler applies these rules to configuration files of supported AI agents
- **Targeted Agent Configuration**: Fine-tune which agents are affected and their specific output paths via `ruler.toml`
- **MCP Server Propagation**: Manage and distribute Model Context Protocol (MCP) server settings
- **`.gitignore` Automation**: Keeps generated agent config files out of version control automatically
- **Simple CLI**: Easy-to-use commands for initialising and applying configurations

## Supported AI Agents

| Agent            | File(s) Created/Updated                                       |
| ---------------- | ------------------------------------------------------------- |
| GitHub Copilot   | `.github/copilot-instructions.md`                             |
| Claude Code      | `CLAUDE.md`                                                   |
| OpenAI Codex CLI | `AGENTS.md`                                                   |
| Cursor           | `.cursor/rules/ruler_cursor_instructions.mdc`                 |
| Windsurf         | `.windsurf/rules/ruler_windsurf_instructions.md`              |
| Cline            | `.clinerules`                                                 |
| Aider            | `ruler_aider_instructions.md` and `.aider.conf.yml`           |
| Firebase Studio  | `.idx/airules.md`                                             |
| Open Hands       | `.openhands/microagents/repo.md` and `.openhands/config.toml` |
| Gemini CLI       | `GEMINI.md` and `.gemini/settings.json`                       |

## Getting Started

### Prerequisites

Node.js 18.x or higher is required.

### Installation

**Global Installation (Recommended for CLI use):**

```bash
npm install -g @intellectronica/ruler
```

**Using `npx` (for one-off commands):**

```bash
npx @intellectronica/ruler apply
```

### Project Initialisation

1. Navigate to your project's root directory
2. Run `ruler init`
3. This creates:
   - `.ruler/` directory
   - `.ruler/instructions.md`: A starter Markdown file for your rules
   - `.ruler/ruler.toml`: The main configuration file for Ruler
   - `.ruler/mcp.json`: An example MCP server configuration

## Core Concepts

### The `.ruler/` Directory

This is your central hub for all AI agent instructions:

- **Rule Files (`*.md`)**: Discovered recursively from `.ruler/` and alphabetically concatenated
- **Concatenation Marker**: Each file's content is prepended with `--- Source: <relative_path_to_md_file> ---` for traceability
- **`ruler.toml`**: Master configuration for Ruler's behavior, agent selection, and output paths
- **`mcp.json`**: Shared MCP server settings

### Best Practices for Rule Files

**Granularity**: Break down complex instructions into focused `.md` files:

- `coding_style.md`
- `api_conventions.md`
- `project_architecture.md`
- `security_guidelines.md`

**Example rule file (`.ruler/python_guidelines.md`):**

```markdown
# Python Project Guidelines

## General Style

- Follow PEP 8 for all Python code
- Use type hints for all function signatures and complex variables
- Keep functions short and focused on a single task

## Error Handling

- Use specific exception types rather than generic `Exception`
- Log errors effectively with context

## Security

- Always validate and sanitize user input
- Be mindful of potential injection vulnerabilities
```

## Usage: The `apply` Command

### Primary Command

```bash
ruler apply [options]
```

### Options

| Option                         | Description                                               |
| ------------------------------ | --------------------------------------------------------- |
| `--project-root <path>`        | Path to your project's root (default: current directory)  |
| `--agents <agent1,agent2,...>` | Comma-separated list of agent names to target             |
| `--config <path>`              | Path to a custom `ruler.toml` configuration file          |
| `--mcp` / `--with-mcp`         | Enable applying MCP server configurations (default: true) |
| `--no-mcp`                     | Disable applying MCP server configurations                |
| `--mcp-overwrite`              | Overwrite native MCP config entirely instead of merging   |
| `--gitignore`                  | Enable automatic .gitignore updates (default: true)       |
| `--no-gitignore`               | Disable automatic .gitignore updates                      |
| `--verbose` / `-v`             | Display detailed output during execution                  |

### Common Examples

**Apply rules to all configured agents:**

```bash
ruler apply
```

**Apply rules only to GitHub Copilot and Claude:**

```bash
ruler apply --agents copilot,claude
```

**Apply rules only to Firebase Studio:**

```bash
ruler apply --agents firebase
```

**Use a specific configuration file:**

```bash
ruler apply --config ./team-configs/ruler.frontend.toml
```

**Apply rules with verbose output:**

```bash
ruler apply --verbose
```

**Apply rules but skip MCP and .gitignore updates:**

```bash
ruler apply --no-mcp --no-gitignore
```

## Configuration (`ruler.toml`) in Detail

### Location

Defaults to `.ruler/ruler.toml` in the project root. Override with `--config` CLI option.

### Complete Example

```toml
# Default agents to run when --agents is not specified
# Uses case-insensitive substring matching
default_agents = ["copilot", "claude", "aider"]

# --- Global MCP Server Configuration ---
[mcp]
# Enable/disable MCP propagation globally (default: true)
enabled = true
# Global merge strategy: 'merge' or 'overwrite' (default: 'merge')
merge_strategy = "merge"

# --- Global .gitignore Configuration ---
[gitignore]
# Enable/disable automatic .gitignore updates (default: true)
enabled = true

# --- Agent-Specific Configurations ---
[agents.copilot]
enabled = true
output_path = ".github/copilot-instructions.md"

[agents.claude]
enabled = true
output_path = "CLAUDE.md"

[agents.aider]
enabled = true
output_path_instructions = "ruler_aider_instructions.md"
output_path_config = ".aider.conf.yml"

[agents.firebase]
enabled = true
output_path = ".idx/airules.md"

[agents.gemini-cli]
enabled = true

# Agent-specific MCP configuration
[agents.cursor.mcp]
enabled = true
merge_strategy = "merge"

# Disable specific agents
[agents.windsurf]
enabled = false
```

### Configuration Precedence

1. **CLI flags** (e.g., `--agents`, `--no-mcp`, `--mcp-overwrite`, `--no-gitignore`)
2. **Settings in `ruler.toml`** (`default_agents`, specific agent settings, global sections)
3. **Ruler's built-in defaults** (all agents enabled, standard output paths, MCP enabled with 'merge')

## MCP (Model Context Protocol) Server Configuration

MCP provides broader context to AI models through server configurations. Ruler can manage and distribute these settings across compatible agents.

### `.ruler/mcp.json`

Define your project's MCP servers:

```json
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "/path/to/project"
      ]
    },
    "git": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-git", "--repository", "."]
    }
  }
}
```

Ruler uses this file with the `merge` (default) or `overwrite` strategy, controlled by `ruler.toml` or CLI flags.

## `.gitignore` Integration

Ruler automatically manages your `.gitignore` file to keep generated agent configuration files out of version control.

### How it Works

- Creates or updates `.gitignore` in your project root
- Adds paths to a managed block marked with `# START Ruler Generated Files` and `# END Ruler Generated Files`
- Preserves existing content outside this block
- Sorts paths alphabetically and uses relative POSIX-style paths

### Example `.gitignore` Section

```gitignore
# Your existing rules
node_modules/
*.log

# START Ruler Generated Files
.aider.conf.yml
.clinerules
.cursor/rules/ruler_cursor_instructions.mdc
.github/copilot-instructions.md
.windsurf/rules/ruler_windsurf_instructions.md
AGENTS.md
CLAUDE.md
ruler_aider_instructions.md
# END Ruler Generated Files

dist/
```

### Control Options

- **CLI flags**: `--gitignore` or `--no-gitignore`
- **Configuration**: `[gitignore].enabled` in `ruler.toml`
- **Default**: enabled

## Practical Usage Scenarios

### Scenario 1: Getting Started Quickly

```bash
# Initialize Ruler in your project
cd your-project
ruler init

# Edit the generated files
# - Add your coding guidelines to .ruler/instructions.md
# - Customize .ruler/ruler.toml if needed

# Apply rules to all AI agents
ruler apply
```

### Scenario 2: Team Standardization

1. Create `.ruler/coding_standards.md`, `.ruler/api_usage.md`
2. Commit the `.ruler` directory to your repository
3. Team members pull changes and run `ruler apply` to update their local AI agent configurations

### Scenario 3: Project-Specific Context for AI

1. Detail your project's architecture in `.ruler/project_overview.md`
2. Describe primary data structures in `.ruler/data_models.md`
3. Run `ruler apply` to help AI tools provide more relevant suggestions

### Integration with NPM Scripts

```json
{
  "scripts": {
    "ruler:apply": "ruler apply",
    "dev": "npm run ruler:apply && your_dev_command",
    "precommit": "npm run ruler:apply"
  }
}
```

### Integration with GitHub Actions

```yaml
# .github/workflows/ruler-check.yml
name: Check Ruler Configuration
on:
  pull_request:
    paths: ['.ruler/**']

jobs:
  check-ruler:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Ruler
        run: npm install -g @intellectronica/ruler

      - name: Apply Ruler configuration
        run: ruler apply --no-gitignore

      - name: Check for uncommitted changes
        run: |
          if [[ -n $(git status --porcelain) ]]; then
            echo "::error::Ruler configuration is out of sync!"
            echo "Please run 'ruler apply' locally and commit the changes."
            exit 1
          fi
```

## Troubleshooting

### Common Issues

**"Cannot find module" errors:**

- Ensure Ruler is installed globally: `npm install -g @intellectronica/ruler`
- Or use `npx @intellectronica/ruler`

**Permission denied errors:**

- On Unix systems, you may need `sudo` for global installation

**Agent files not updating:**

- Check if the agent is enabled in `ruler.toml`
- Verify agent isn't excluded by `--agents` flag
- Use `--verbose` to see detailed execution logs

**Configuration validation errors:**

- Ruler now validates `ruler.toml` format and will show specific error details
- Check that all configuration values match the expected types and formats

### Debug Mode

Use `--verbose` flag to see detailed execution logs:

```bash
ruler apply --verbose
```

This shows:

- Configuration loading details
- Agent selection logic
- File processing information
- MCP configuration steps

## FAQ

**Q: Can I use different rules for different agents?**
A: Currently, all agents receive the same concatenated rules. For agent-specific instructions, include sections in your rule files like "## GitHub Copilot Specific" or "## Aider Configuration".

**Q: How do I temporarily disable Ruler for an agent?**
A: Set `enabled = false` in `ruler.toml` under `[agents.agentname]`, or use `--agents` flag to specify only the agents you want.

**Q: What happens to my existing agent configuration files?**
A: Ruler creates backups with `.bak` extension before overwriting any existing files.

**Q: Can I run Ruler in CI/CD pipelines?**
A: Yes! Use `ruler apply --no-gitignore` in CI to avoid modifying `.gitignore`. See the GitHub Actions example above.

**Q: How do I migrate from version 0.1.x to 0.2.0?**
A: Version 0.2.0 is backward compatible. Your existing `.ruler/` directory and `ruler.toml` will continue to work. New features like verbose logging and improved error messages are opt-in.

## Development

### Setup

```bash
git clone https://github.com/intellectronica/ruler.git
cd ruler
npm install
npm run build
```

### Testing

```bash
# Run all tests
npm test

# Run tests with coverage
npm run test:coverage

# Run tests in watch mode
npm run test:watch
```

### Code Quality

```bash
# Run linting
npm run lint

# Run formatting
npm run format
```

## Contributing

Contributions are welcome! Please:

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Ensure all tests pass
6. Submit a pull request

For bugs and feature requests, please [open an issue](https://github.com/intellectronica/ruler/issues).

## License

MIT

---

© Eleanor Berger  
[ai.intellectronica.net](https://ai.intellectronica.net/)
</file>

<file path="src/lib.ts">
import * as path from 'path';
import { promises as fs } from 'fs';
import * as FileSystemUtils from './core/FileSystemUtils';
import { concatenateRules } from './core/RuleProcessor';
import { loadConfig } from './core/ConfigLoader';
import { updateGitignore } from './core/GitignoreUtils';
import { IAgent } from './agents/IAgent';
import { CopilotAgent } from './agents/CopilotAgent';
import { ClaudeAgent } from './agents/ClaudeAgent';
import { CodexCliAgent } from './agents/CodexCliAgent';
import { CursorAgent } from './agents/CursorAgent';
import { WindsurfAgent } from './agents/WindsurfAgent';
import * as ClineAgent from './agents/ClineAgent';
import { AiderAgent } from './agents/AiderAgent';
import { FirebaseAgent } from './agents/FirebaseAgent';
import { OpenHandsAgent } from './agents/OpenHandsAgent';
import { GeminiCliAgent } from './agents/GeminiCliAgent';
import { mergeMcp } from './mcp/merge';
import { validateMcp } from './mcp/validate';
import { getNativeMcpPath, readNativeMcp, writeNativeMcp } from './paths/mcp';
import { McpStrategy } from './types';
import { propagateMcpToOpenHands } from './mcp/propagateOpenHandsMcp';
import { IAgentConfig } from './agents/IAgent';
import { createRulerError, logVerbose } from './constants';
/**
 * Gets all output paths for an agent, taking into account any config overrides.
 */
function getAgentOutputPaths(
  agent: IAgent,
  projectRoot: string,
  agentConfig?: IAgentConfig,
): string[] {
  const paths: string[] = [];
  const defaults = agent.getDefaultOutputPath(projectRoot);
  if (typeof defaults === 'string') {
    // Single output path (most agents)
    const actualPath = agentConfig?.outputPath ?? defaults;
    paths.push(actualPath);
  } else {
    // Multiple output paths (e.g., AiderAgent)
    const defaultPaths = defaults as Record<string, string>;
    // Handle instructions path
    if ('instructions' in defaultPaths) {
      const instructionsPath =
        agentConfig?.outputPathInstructions ?? defaultPaths.instructions;
      paths.push(instructionsPath);
    }
    // Handle config path
    if ('config' in defaultPaths) {
      const configPath = agentConfig?.outputPathConfig ?? defaultPaths.config;
      paths.push(configPath);
    }
    // Handle any other paths in the default paths record
    for (const [key, defaultPath] of Object.entries(defaultPaths)) {
      if (key !== 'instructions' && key !== 'config') {
        // For unknown path types, use the default since we don't have specific config overrides
        paths.push(defaultPath);
      }
    }
  }
  return paths;
}
const agents: IAgent[] = [
  new CopilotAgent(),
  new ClaudeAgent(),
  new CodexCliAgent(),
  new CursorAgent(),
  new WindsurfAgent(),
  new ClineAgent.ClineAgent(),
  new AiderAgent(),
  new FirebaseAgent(),
  new OpenHandsAgent(),
  new GeminiCliAgent(),
];
/**
 * Applies ruler configurations for all supported AI agents.
 * @param projectRoot Root directory of the project
 */
/**
 * Applies ruler configurations for selected AI agents.
 * @param projectRoot Root directory of the project
 * @param includedAgents Optional list of agent name filters (case-insensitive substrings)
 */
export async function applyAllAgentConfigs(
  projectRoot: string,
  includedAgents?: string[],
  configPath?: string,
  cliMcpEnabled = true,
  cliMcpStrategy?: McpStrategy,
  cliGitignoreEnabled?: boolean,
  verbose = false,
  dryRun = false,
): Promise<void> {
  // Load configuration (default_agents, per-agent overrides, CLI filters)
  logVerbose(
    `Loading configuration from project root: ${projectRoot}`,
    verbose,
  );
  if (configPath) {
    logVerbose(`Using custom config path: ${configPath}`, verbose);
  }
  const config = await loadConfig({
    projectRoot,
    cliAgents: includedAgents,
    configPath,
  });
  logVerbose(
    `Loaded configuration with ${Object.keys(config.agentConfigs).length} agent configs`,
    verbose,
  );
  // Normalize per-agent config keys to agent identifiers (exact match or substring match)
  const rawConfigs = config.agentConfigs;
  const mappedConfigs: Record<string, (typeof rawConfigs)[string]> = {};
  for (const [key, cfg] of Object.entries(rawConfigs)) {
    const lowerKey = key.toLowerCase();
    for (const agent of agents) {
      const identifier = agent.getIdentifier();
      // Exact match with identifier or substring match with display name for backwards compatibility
      if (
        identifier === lowerKey ||
        agent.getName().toLowerCase().includes(lowerKey)
      ) {
        mappedConfigs[identifier] = cfg;
      }
    }
  }
  config.agentConfigs = mappedConfigs;
  const rulerDir = await FileSystemUtils.findRulerDir(projectRoot);
  if (!rulerDir) {
    throw createRulerError(
      `.ruler directory not found`,
      `Searched from: ${projectRoot}`,
    );
  }
  logVerbose(`Found .ruler directory at: ${rulerDir}`, verbose);
  const files = await FileSystemUtils.readMarkdownFiles(rulerDir);
  logVerbose(
    `Found ${files.length} markdown files in .ruler directory`,
    verbose,
  );
  const concatenated = concatenateRules(files);
  logVerbose(
    `Concatenated rules length: ${concatenated.length} characters`,
    verbose,
  );
  const mcpFile = path.join(rulerDir, 'mcp.json');
  let rulerMcpJson: Record<string, unknown> | null = null;
  try {
    const raw = await fs.readFile(mcpFile, 'utf8');
    rulerMcpJson = JSON.parse(raw) as Record<string, unknown>;
    validateMcp(rulerMcpJson);
    logVerbose(`Loaded MCP configuration from: ${mcpFile}`, verbose);
  } catch (err: unknown) {
    if ((err as NodeJS.ErrnoException).code !== 'ENOENT') {
      throw createRulerError(
        `Failed to load MCP configuration`,
        `File: ${mcpFile}, Error: ${(err as Error).message}`,
      );
    }
    logVerbose(`No MCP configuration found at: ${mcpFile}`, verbose);
  }
  // Determine which agents to run:
  // CLI --agents > config.default_agents > per-agent.enabled flags > default all
  let selected = agents;
  if (config.cliAgents && config.cliAgents.length > 0) {
    const filters = config.cliAgents.map((n) => n.toLowerCase());
    selected = agents.filter((agent) =>
      filters.some(
        (f) =>
          agent.getIdentifier() === f ||
          agent.getName().toLowerCase().includes(f),
      ),
    );
    logVerbose(
      `Selected agents via CLI filter: ${selected.map((a) => a.getName()).join(', ')}`,
      verbose,
    );
  } else if (config.defaultAgents && config.defaultAgents.length > 0) {
    const defaults = config.defaultAgents.map((n) => n.toLowerCase());
    selected = agents.filter((agent) => {
      const identifier = agent.getIdentifier();
      const override = config.agentConfigs[identifier]?.enabled;
      if (override !== undefined) {
        return override;
      }
      return defaults.some(
        (d) => identifier === d || agent.getName().toLowerCase().includes(d),
      );
    });
    logVerbose(
      `Selected agents via config default_agents: ${selected.map((a) => a.getName()).join(', ')}`,
      verbose,
    );
  } else {
    selected = agents.filter(
      (agent) => config.agentConfigs[agent.getIdentifier()]?.enabled !== false,
    );
    logVerbose(
      `Selected all enabled agents: ${selected.map((a) => a.getName()).join(', ')}`,
      verbose,
    );
  }
  // Collect all generated file paths for .gitignore
  const generatedPaths: string[] = [];
  for (const agent of selected) {
    const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';
    console.log(`${actionPrefix} Applying rules for ${agent.getName()}...`);
    logVerbose(`Processing agent: ${agent.getName()}`, verbose);
    const agentConfig = config.agentConfigs[agent.getIdentifier()];
    // Collect output paths for .gitignore
    const outputPaths = getAgentOutputPaths(agent, projectRoot, agentConfig);
    logVerbose(
      `Agent ${agent.getName()} output paths: ${outputPaths.join(', ')}`,
      verbose,
    );
    generatedPaths.push(...outputPaths);
    if (dryRun) {
      logVerbose(
        `DRY RUN: Would write rules to: ${outputPaths.join(', ')}`,
        verbose,
      );
    } else {
      await agent.applyRulerConfig(
        concatenated,
        projectRoot,
        rulerMcpJson,
        agentConfig,
      );
    }
    const dest = await getNativeMcpPath(agent.getName(), projectRoot);
    const mcpEnabledForAgent =
      cliMcpEnabled &&
      (agentConfig?.mcp?.enabled ?? config.mcp?.enabled ?? true);
    const rulerMcpFile = path.join(rulerDir, 'mcp.json');
    if (dest && mcpEnabledForAgent) {
      if (agent.getIdentifier() === 'openhands') {
        // *** Special handling for Open Hands ***
        if (dryRun) {
          logVerbose(
            `DRY RUN: Would apply MCP config by updating TOML file: ${dest}`,
            verbose,
          );
        } else {
          await propagateMcpToOpenHands(rulerMcpFile, dest);
        }
        // Include Open Hands config file in .gitignore
        generatedPaths.push(dest);
      } else {
        if (rulerMcpJson) {
          const strategy =
            cliMcpStrategy ??
            agentConfig?.mcp?.strategy ??
            config.mcp?.strategy ??
            'merge';
          // Determine the correct server key for the agent
          const serverKey = agent.getMcpServerKey?.() ?? 'mcpServers';
          logVerbose(
            `Applying MCP config for ${agent.getName()} with strategy: ${strategy} and key: ${serverKey}`,
            verbose,
          );
          if (dryRun) {
            logVerbose(`DRY RUN: Would apply MCP config to: ${dest}`, true);
          } else {
            const existing = await readNativeMcp(dest);
            const merged = mergeMcp(
              existing,
              rulerMcpJson,
              strategy,
              serverKey,
            );
            await writeNativeMcp(dest, merged);
          }
        }
      }
    }
  }
  // Handle .gitignore updates
  // Configuration precedence: CLI > TOML > Default (enabled)
  let gitignoreEnabled: boolean;
  if (cliGitignoreEnabled !== undefined) {
    gitignoreEnabled = cliGitignoreEnabled;
  } else if (config.gitignore?.enabled !== undefined) {
    gitignoreEnabled = config.gitignore.enabled;
  } else {
    gitignoreEnabled = true; // Default enabled
  }
  if (gitignoreEnabled && generatedPaths.length > 0) {
    // Filter out .bak files as specified in requirements
    const pathsToIgnore = generatedPaths.filter((p) => !p.endsWith('.bak'));
    const uniquePaths = [...new Set(pathsToIgnore)];
    if (uniquePaths.length > 0) {
      const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';
      if (dryRun) {
        console.log(
          `${actionPrefix} Would update .gitignore with ${uniquePaths.length} unique path(s): ${uniquePaths.join(', ')}`,
        );
      } else {
        await updateGitignore(projectRoot, uniquePaths);
        console.log(
          `${actionPrefix} Updated .gitignore with ${uniquePaths.length} unique path(s) in the Ruler block.`,
        );
      }
    }
  }
}
</file>

<file path="src/agents/GeminiCliAgent.ts">
import { IAgent, IAgentConfig } from './IAgent';
import * as path from 'path';
import { promises as fs } from 'fs';
import { mergeMcp } from '../mcp/merge';
export class GeminiCliAgent implements IAgent {
  getIdentifier(): string {
    return 'gemini-cli';
  }
  getName(): string {
    return 'Gemini CLI';
  }
  async applyRulerConfig(
    concatenatedRules: string,
    projectRoot: string,
    rulerMcpJson: Record<string, unknown> | null,
    agentConfig?: IAgentConfig,
  ): Promise<void> {
    const outputPath = this.getDefaultOutputPath(projectRoot);
    await fs.writeFile(outputPath as string, concatenatedRules);
    if (rulerMcpJson) {
      const settingsPath = path.join(projectRoot, '.gemini', 'settings.json');
      let existingSettings: Record<string, unknown> = {};
      try {
        const existingSettingsRaw = await fs.readFile(settingsPath, 'utf8');
        existingSettings = JSON.parse(existingSettingsRaw);
      } catch (error: unknown) {
        if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
          throw error;
        }
      }
      const merged = mergeMcp(
        existingSettings,
        rulerMcpJson,
        agentConfig?.mcp?.strategy ?? 'merge',
        this.getMcpServerKey(),
      );
      await fs.mkdir(path.dirname(settingsPath), { recursive: true });
      await fs.writeFile(settingsPath, JSON.stringify(merged, null, 2));
    }
  }
  getDefaultOutputPath(projectRoot: string): string {
    return path.join(projectRoot, 'GEMINI.md');
  }
  getMcpServerKey(): string {
    return 'mcpServers';
  }
}
</file>

</files>
