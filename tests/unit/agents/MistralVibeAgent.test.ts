import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { parse as parseTOML } from '@iarna/toml';

import { MistralVibeAgent } from '../../../src/agents/MistralVibeAgent';

describe('MistralVibeAgent', () => {
  let tmpDir: string;
  let agent: MistralVibeAgent;

  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-mistral-'));
    agent = new MistralVibeAgent();
  });

  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });

  describe('identity', () => {
    it('has correct identifier', () => {
      expect(agent.getIdentifier()).toBe('mistral');
    });

    it('has correct name', () => {
      expect(agent.getName()).toBe('Mistral');
    });
  });

  describe('default output paths', () => {
    it('returns correct default paths', () => {
      const paths = agent.getDefaultOutputPath(tmpDir);
      expect(paths).toEqual({
        instructions: path.join(tmpDir, 'AGENTS.md'),
        config: path.join(tmpDir, '.vibe', 'config.toml'),
      });
    });
  });

  describe('MCP support', () => {
    it('supports stdio MCP servers', () => {
      expect(agent.supportsMcpStdio()).toBe(true);
    });

    it('supports remote MCP servers', () => {
      expect(agent.supportsMcpRemote()).toBe(true);
    });

    it('does not support native skills', () => {
      expect(agent.supportsNativeSkills()).toBe(false);
    });
  });

  describe('applyRulerConfig', () => {
    it('writes instructions to AGENTS.md', async () => {
      await agent.applyRulerConfig('test rules', tmpDir, null, {
        mcp: { enabled: false },
      });

      const instructionsPath = path.join(tmpDir, 'AGENTS.md');
      const content = await fs.readFile(instructionsPath, 'utf8');
      expect(content).toBe('<!-- Generated by Ruler -->\ntest rules');
    });

    it('creates MCP config with stdio server', async () => {
      const mcpJson = {
        mcpServers: {
          test_server: {
            command: 'npx',
            args: ['-y', 'test-mcp-server'],
            env: { API_KEY: 'test-key' },
          },
        },
      };

      await agent.applyRulerConfig('rules', tmpDir, mcpJson, {
        mcp: { enabled: true },
      });

      const configPath = path.join(tmpDir, '.vibe', 'config.toml');
      const content = await fs.readFile(configPath, 'utf8');
      const parsed = parseTOML(content) as any;

      expect(parsed.mcp_servers).toHaveLength(1);
      expect(parsed.mcp_servers[0].name).toBe('test_server');
      expect(parsed.mcp_servers[0].transport).toBe('stdio');
      expect(parsed.mcp_servers[0].command).toBe('npx');
      expect(parsed.mcp_servers[0].args).toEqual(['-y', 'test-mcp-server']);
      expect(parsed.mcp_servers[0].env.API_KEY).toBe('test-key');
    });

    it('creates MCP config with remote server', async () => {
      const mcpJson = {
        mcpServers: {
          remote_api: {
            url: 'https://api.example.com',
            headers: { Authorization: 'Bearer token' },
          },
        },
      };

      await agent.applyRulerConfig('rules', tmpDir, mcpJson, {
        mcp: { enabled: true },
      });

      const configPath = path.join(tmpDir, '.vibe', 'config.toml');
      const content = await fs.readFile(configPath, 'utf8');
      const parsed = parseTOML(content) as any;

      expect(parsed.mcp_servers).toHaveLength(1);
      expect(parsed.mcp_servers[0].name).toBe('remote_api');
      expect(parsed.mcp_servers[0].transport).toBe('http');
      expect(parsed.mcp_servers[0].url).toBe('https://api.example.com');
      expect(parsed.mcp_servers[0].headers.Authorization).toBe('Bearer token');
    });

    it('merges servers when strategy is merge', async () => {
      // Pre-create config with existing server
      const configPath = path.join(tmpDir, '.vibe', 'config.toml');
      await fs.mkdir(path.dirname(configPath), { recursive: true });
      const existingConfig = `
[[mcp_servers]]
name = "existing_server"
transport = "stdio"
command = "npx"
args = ["-y", "existing-mcp"]
`;
      await fs.writeFile(configPath, existingConfig);

      const mcpJson = {
        mcpServers: {
          new_server: {
            command: 'npx',
            args: ['-y', 'new-mcp'],
          },
        },
      };

      await agent.applyRulerConfig('rules', tmpDir, mcpJson, {
        mcp: { enabled: true, strategy: 'merge' },
      });

      const content = await fs.readFile(configPath, 'utf8');
      const parsed = parseTOML(content) as any;

      expect(parsed.mcp_servers).toHaveLength(2);

      const existingServer = parsed.mcp_servers.find(
        (s: any) => s.name === 'existing_server',
      );
      const newServer = parsed.mcp_servers.find(
        (s: any) => s.name === 'new_server',
      );

      expect(existingServer).toBeDefined();
      expect(existingServer.command).toBe('npx');
      expect(existingServer.args).toEqual(['-y', 'existing-mcp']);

      expect(newServer).toBeDefined();
      expect(newServer.command).toBe('npx');
      expect(newServer.args).toEqual(['-y', 'new-mcp']);
    });

    it('overwrites servers when strategy is overwrite', async () => {
      // Pre-create config with existing server
      const configPath = path.join(tmpDir, '.vibe', 'config.toml');
      await fs.mkdir(path.dirname(configPath), { recursive: true });
      const existingConfig = `
[[mcp_servers]]
name = "existing_server"
transport = "stdio"
command = "npx"
args = ["-y", "existing-mcp"]
`;
      await fs.writeFile(configPath, existingConfig);

      const mcpJson = {
        mcpServers: {
          new_server: {
            command: 'npx',
            args: ['-y', 'new-mcp'],
          },
        },
      };

      await agent.applyRulerConfig('rules', tmpDir, mcpJson, {
        mcp: { enabled: true, strategy: 'overwrite' },
      });

      const content = await fs.readFile(configPath, 'utf8');
      const parsed = parseTOML(content) as any;

      expect(parsed.mcp_servers).toHaveLength(1);
      expect(parsed.mcp_servers[0].name).toBe('new_server');
      expect(parsed.mcp_servers[0].command).toBe('npx');
    });

    it('replaces existing server with same name during merge', async () => {
      // Pre-create config with existing server
      const configPath = path.join(tmpDir, '.vibe', 'config.toml');
      await fs.mkdir(path.dirname(configPath), { recursive: true });
      const existingConfig = `
[[mcp_servers]]
name = "shared_server"
transport = "stdio"
command = "old-command"
args = ["-y", "old-mcp"]
`;
      await fs.writeFile(configPath, existingConfig);

      const mcpJson = {
        mcpServers: {
          shared_server: {
            command: 'new-command',
            args: ['-y', 'new-mcp'],
          },
        },
      };

      await agent.applyRulerConfig('rules', tmpDir, mcpJson, {
        mcp: { enabled: true, strategy: 'merge' },
      });

      const content = await fs.readFile(configPath, 'utf8');
      const parsed = parseTOML(content) as any;

      expect(parsed.mcp_servers).toHaveLength(1);
      expect(parsed.mcp_servers[0].name).toBe('shared_server');
      expect(parsed.mcp_servers[0].command).toBe('new-command');
      expect(parsed.mcp_servers[0].args).toEqual(['-y', 'new-mcp']);
    });

    it('preserves other config properties', async () => {
      // Pre-create config with other properties
      const configPath = path.join(tmpDir, '.vibe', 'config.toml');
      await fs.mkdir(path.dirname(configPath), { recursive: true });
      const existingConfig = `
system_prompt_id = "custom_prompt"
active_model = "devstral-2"

[[mcp_servers]]
name = "existing_server"
transport = "stdio"
command = "npx"
args = ["-y", "existing-mcp"]
`;
      await fs.writeFile(configPath, existingConfig);

      const mcpJson = {
        mcpServers: {
          new_server: {
            command: 'npx',
            args: ['-y', 'new-mcp'],
          },
        },
      };

      await agent.applyRulerConfig('rules', tmpDir, mcpJson, {
        mcp: { enabled: true, strategy: 'merge' },
      });

      const content = await fs.readFile(configPath, 'utf8');
      const parsed = parseTOML(content) as any;

      expect(parsed.system_prompt_id).toBe('custom_prompt');
      expect(parsed.active_model).toBe('devstral-2');
      expect(parsed.mcp_servers).toHaveLength(2);
    });

    it('uses custom config path when provided', async () => {
      const customPath = path.join(tmpDir, 'custom', 'vibe.toml');
      await fs.mkdir(path.dirname(customPath), { recursive: true });

      const mcpJson = {
        mcpServers: {
          test_server: {
            command: 'npx',
            args: ['-y', 'test-mcp'],
          },
        },
      };

      await agent.applyRulerConfig('rules', tmpDir, mcpJson, {
        mcp: { enabled: true },
        outputPathConfig: customPath,
      });

      const exists = await fs.stat(customPath);
      expect(exists.isFile()).toBe(true);

      const content = await fs.readFile(customPath, 'utf8');
      const parsed = parseTOML(content) as any;
      expect(parsed.mcp_servers[0].name).toBe('test_server');
    });

    it('skips MCP config when disabled', async () => {
      const mcpJson = {
        mcpServers: {
          test_server: {
            command: 'npx',
            args: ['-y', 'test-mcp'],
          },
        },
      };

      await agent.applyRulerConfig('rules', tmpDir, mcpJson, {
        mcp: { enabled: false },
      });

      const configPath = path.join(tmpDir, '.vibe', 'config.toml');
      await expect(fs.access(configPath)).rejects.toThrow();
    });

    it('handles multiple servers of different types', async () => {
      const mcpJson = {
        mcpServers: {
          stdio_server: {
            command: 'npx',
            args: ['-y', 'stdio-mcp'],
            env: { DEBUG: '1' },
          },
          http_server: {
            url: 'https://api.example.com',
            headers: { 'X-API-Key': 'secret' },
          },
        },
      };

      await agent.applyRulerConfig('rules', tmpDir, mcpJson, {
        mcp: { enabled: true },
      });

      const configPath = path.join(tmpDir, '.vibe', 'config.toml');
      const content = await fs.readFile(configPath, 'utf8');
      const parsed = parseTOML(content) as any;

      expect(parsed.mcp_servers).toHaveLength(2);

      const stdioServer = parsed.mcp_servers.find(
        (s: any) => s.name === 'stdio_server',
      );
      const httpServer = parsed.mcp_servers.find(
        (s: any) => s.name === 'http_server',
      );

      expect(stdioServer.transport).toBe('stdio');
      expect(stdioServer.command).toBe('npx');
      expect(stdioServer.env.DEBUG).toBe('1');

      expect(httpServer.transport).toBe('http');
      expect(httpServer.url).toBe('https://api.example.com');
      expect(httpServer.headers['X-API-Key']).toBe('secret');
    });
  });
});
