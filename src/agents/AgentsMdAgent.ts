import * as path from 'path';
import { promises as fs } from 'fs';
import { AbstractAgent } from './AbstractAgent';
import { IAgentConfig } from './IAgent';
import {
  backupFile,
  ensureDirExists,
  writeGeneratedFile,
} from '../core/FileSystemUtils';

/**
 * Pseudo-agent that ensures the concatenated rules are written to root-level `AGENTS.md`.
 * Does not participate in MCP propagation. Idempotent: only writes (and creates a backup)
 * when content differs from existing file.
 */
export class AgentsMdAgent extends AbstractAgent {
  getIdentifier(): string {
    return 'agentsmd';
  }

  getName(): string {
    return 'AgentsMd';
  }

  getDefaultOutputPath(projectRoot: string): string {
    return path.join(projectRoot, 'AGENTS.md');
  }

  async applyRulerConfig(
    concatenatedRules: string,
    projectRoot: string,
    _rulerMcpJson: Record<string, unknown> | null,
    agentConfig?: IAgentConfig,
    backup = true,
  ): Promise<void> {
    const output =
      agentConfig?.outputPath ?? this.getDefaultOutputPath(projectRoot);
    const absolutePath = path.resolve(projectRoot, output);
    await ensureDirExists(path.dirname(absolutePath));

    // Add marker comment to the content to identify it as generated
    const contentWithMarker = `<!-- Generated by Ruler -->\n${concatenatedRules}`;

    // Read existing content if present and skip write if identical
    let existing: string | null = null;
    try {
      existing = await fs.readFile(absolutePath, 'utf8');
    } catch {
      existing = null;
    }

    if (existing !== null && existing === contentWithMarker) {
      // No change; skip backup/write for idempotency
      return;
    }

    // Backup (only if file existed and backup is enabled) then write new content
    if (backup) {
      await backupFile(absolutePath);
    }
    await writeGeneratedFile(absolutePath, contentWithMarker);
  }

  getMcpServerKey(): string {
    // No MCP configuration for this pseudo-agent
    return '';
  }
}
