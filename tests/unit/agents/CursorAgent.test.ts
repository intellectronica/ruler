import { promises as fs } from 'fs';
import * as path from 'path';
import os from 'os';

import { CursorAgent } from '../../../src/agents/CursorAgent';

describe('CursorAgent', () => {
  let tmpDir: string;

  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-cursor-'));
  });

  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });

  const expectedMarker = '<!-- Generated by Ruler -->\n';

  describe('Basic Agent Interface', () => {
    it('returns correct identifier', () => {
      const agent = new CursorAgent();
      expect(agent.getIdentifier()).toBe('cursor');
    });

    it('returns correct display name', () => {
      const agent = new CursorAgent();
      expect(agent.getName()).toBe('Cursor');
    });

    it('returns correct default output path for AGENTS.md', () => {
      const agent = new CursorAgent();
      const expected = path.join(tmpDir, 'AGENTS.md');
      expect(agent.getDefaultOutputPath(tmpDir)).toBe(expected);
    });
  });

  describe('File Operations', () => {
    it('writes AGENTS.md with marker comment', async () => {
      const agent = new CursorAgent();
      const target = path.join(tmpDir, 'AGENTS.md');

      const sampleRules = 'Sample concatenated rules';

      await agent.applyRulerConfig(sampleRules, tmpDir, null);

      const written = await fs.readFile(target, 'utf8');

      // Check that the file starts with the marker comment
      expect(written.startsWith(expectedMarker)).toBe(true);

      // Check that the original rules content follows the marker
      expect(written).toBe(`${expectedMarker}${sampleRules}`);
    });

    it('backs up existing file before writing', async () => {
      const agent = new CursorAgent();
      const target = path.join(tmpDir, 'AGENTS.md');

      // Create an existing file
      await fs.writeFile(target, 'old cursor rules');

      await agent.applyRulerConfig('new cursor rules', tmpDir, null);

      // Backup should exist with original content
      const backupContent = await fs.readFile(`${target}.bak`, 'utf8');
      expect(backupContent).toBe('old cursor rules');
    });

    it('is idempotent when content is unchanged', async () => {
      const agent = new CursorAgent();
      const target = path.join(tmpDir, 'AGENTS.md');
      const sampleRules = 'Sample rules content';

      // First write
      await agent.applyRulerConfig(sampleRules, tmpDir, null);
      const stat1 = await fs.stat(target);

      // Wait a bit to ensure timestamp would differ if file was rewritten
      await new Promise((resolve) => setTimeout(resolve, 10));

      // Second write with same content
      await agent.applyRulerConfig(sampleRules, tmpDir, null);
      const stat2 = await fs.stat(target);

      // File should not have been rewritten (same modification time)
      expect(stat2.mtimeMs).toBe(stat1.mtimeMs);
    });
  });

  describe('MCP Support', () => {
    it('supports MCP stdio', () => {
      const agent = new CursorAgent();
      expect(agent.supportsMcpStdio()).toBe(true);
    });

    it('supports MCP remote', () => {
      const agent = new CursorAgent();
      expect(agent.supportsMcpRemote()).toBe(true);
    });
  });
});

