import * as fs from "fs/promises";
import * as path from "path";
import * as os from "os";
import { readMarkdownFiles } from "../../../src/core/FileSystemUtils";

/**
 * Test specific edge cases that might cause the bug to surface
 */
describe("Edge case duplication scenarios", () => {
	let tmpDir: string;
	let skillerDir: string;

	beforeEach(async () => {
		tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), "skiller-edge-test-"));
		skillerDir = path.join(tmpDir, ".claude");
		await fs.mkdir(skillerDir, { recursive: true });
	});

	afterEach(async () => {
		await fs.rm(tmpDir, { recursive: true, force: true });
	});

	it("should handle the case when both root AGENTS.md and .claude/AGENTS.md exist", async () => {
		// This might be the exact bug scenario

		// Step 1: Create .claude/AGENTS.md with original content
		const skillerAgentsContent = "Original rules from .claude/AGENTS.md";
		await fs.writeFile(path.join(skillerDir, "AGENTS.md"), skillerAgentsContent);

		// Step 2: First read should include only the .claude/AGENTS.md
		let files = await readMarkdownFiles(skillerDir);
		console.log("First read - files:");
		files.forEach((f) =>
			console.log(`  ${f.path}: ${JSON.stringify(f.content)}`),
		);

		// Step 3: Create generated root AGENTS.md (like AgentsMd would do)
		const generatedContent = `<!-- Generated by Skiller -->\n${skillerAgentsContent}`;
		await fs.writeFile(path.join(tmpDir, "AGENTS.md"), generatedContent);

		// Step 4: Second read should still only include .claude/AGENTS.md (skip the generated root one)
		files = await readMarkdownFiles(skillerDir);
		console.log("Second read - files:");
		files.forEach((f) =>
			console.log(`  ${f.path}: ${JSON.stringify(f.content)}`),
		);

		// Should still be just the .claude/AGENTS.md file, no duplication
		expect(files).toHaveLength(1);
		expect(files[0].content).toBe(skillerAgentsContent);
		expect(files[0].content).not.toContain("<!-- Generated by Skiller -->");
	});

	it("should handle case with nested directories in .claude", async () => {
		// Maybe the bug happens with nested structure

		// Create nested structure
		await fs.mkdir(path.join(skillerDir, "sub"), { recursive: true });
		await fs.writeFile(path.join(skillerDir, "main.md"), "Main content");
		await fs.writeFile(
			path.join(skillerDir, "sub", "nested.md"),
			"Nested content",
		);

		// First read
		let files = await readMarkdownFiles(skillerDir);
		console.log("Nested structure - first read:");
		files.forEach((f) =>
			console.log(`  ${f.path}: ${JSON.stringify(f.content)}`),
		);

		// Create generated root AGENTS.md
		const generatedContent = `<!-- Generated by Skiller -->\nMain content\n\nNested content`;
		await fs.writeFile(path.join(tmpDir, "AGENTS.md"), generatedContent);

		// Second read - should skip the generated root file
		files = await readMarkdownFiles(skillerDir);
		console.log("Nested structure - second read:");
		files.forEach((f) =>
			console.log(`  ${f.path}: ${JSON.stringify(f.content)}`),
		);

		// Should still have the same files from .claude directory
		expect(files).toHaveLength(2);
		expect(files.some((f) => f.content === "Main content")).toBe(true);
		expect(files.some((f) => f.content === "Nested content")).toBe(true);
		expect(
			files.every((f) => !f.content.includes("<!-- Generated by Skiller -->")),
		).toBe(true);
	});

	it("should handle empty skiller directory with generated root file", async () => {
		// This might cause the bug if the logic is wrong

		// Start with empty .claude directory
		// But create a generated root AGENTS.md
		const generatedContent =
			"<!-- Generated by Skiller -->\nSome generated content";
		await fs.writeFile(path.join(tmpDir, "AGENTS.md"), generatedContent);

		// Read files - should include the generated file since there are no .claude files
		let files = await readMarkdownFiles(skillerDir);
		console.log("Empty .claude with generated root:");
		files.forEach((f) =>
			console.log(`  ${f.path}: ${JSON.stringify(f.content)}`),
		);

		// Should include the generated file since there are no skiller files
		expect(files).toHaveLength(1);
		expect(files[0].content).toBe(generatedContent);

		// Now add a file to .claude
		await fs.writeFile(path.join(skillerDir, "new.md"), "New skiller content");

		// Read again - should now skip the generated root file
		files = await readMarkdownFiles(skillerDir);
		console.log("After adding file to .claude:");
		files.forEach((f) =>
			console.log(`  ${f.path}: ${JSON.stringify(f.content)}`),
		);

		// Should only include the new skiller file
		expect(files).toHaveLength(1);
		expect(files[0].content).toBe("New skiller content");
		expect(files[0].content).not.toContain("<!-- Generated by Skiller -->");
	});
});
