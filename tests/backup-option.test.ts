import * as fs from 'fs/promises';
import * as path from 'path';
import { setupTestProject, teardownTestProject, runRuler } from './harness';

describe('backup option', () => {
  let testProject: { projectRoot: string };

  beforeEach(async () => {
    testProject = await setupTestProject({
      '.ruler/AGENTS.md': '# Test Rules\n\nSome test rules here.',
      '.ruler/ruler.toml': '# Test config\ndefault_agents = ["copilot"]\n',
      'AGENTS.md': '# Existing file\nThis should be backed up.',
    });
  });

  afterEach(async () => {
    await teardownTestProject(testProject.projectRoot);
  });

  it('creates .bak files by default', async () => {
    const { projectRoot } = testProject;
    const targetFile = path.join(projectRoot, 'AGENTS.md');
    const backupFile = path.join(projectRoot, 'AGENTS.md.bak');
    
    runRuler('apply', projectRoot);
    
    // Check that backup file was created
    const backupExists = await fs.access(backupFile).then(() => true).catch(() => false);
    expect(backupExists).toBe(true);
    
    // Check backup file content matches original
    const backupContent = await fs.readFile(backupFile, 'utf8');
    expect(backupContent).toBe('# Existing file\nThis should be backed up.');
  });

  it('creates .bak files with --backup flag', async () => {
    const { projectRoot } = testProject;
    const targetFile = path.join(projectRoot, 'AGENTS.md');
    const backupFile = path.join(projectRoot, 'AGENTS.md.bak');
    
    runRuler('apply --backup', projectRoot);
    
    // Check that backup file was created
    const backupExists = await fs.access(backupFile).then(() => true).catch(() => false);
    expect(backupExists).toBe(true);
    
    // Check backup file content matches original
    const backupContent = await fs.readFile(backupFile, 'utf8');
    expect(backupContent).toBe('# Existing file\nThis should be backed up.');
  });

  it('does not create .bak files with --no-backup flag', async () => {
    const { projectRoot } = testProject;
    const targetFile = path.join(projectRoot, 'AGENTS.md');
    const backupFile = path.join(projectRoot, 'AGENTS.md.bak');
    
    runRuler('apply --no-backup', projectRoot);
    
    // Check that backup file was NOT created
    const backupExists = await fs.access(backupFile).then(() => true).catch(() => false);
    expect(backupExists).toBe(false);
    
    // Check that the target file was still updated
    const targetContent = await fs.readFile(targetFile, 'utf8');
    expect(targetContent).toContain('# Test Rules');
    expect(targetContent).toContain('Some test rules here.');
  });

  it('does not add .bak paths to .gitignore with --no-backup', async () => {
    const { projectRoot } = testProject;
    const gitignoreFile = path.join(projectRoot, '.gitignore');
    
    runRuler('apply --no-backup', projectRoot);
    
    // Check .gitignore content
    const gitignoreContent = await fs.readFile(gitignoreFile, 'utf8');
    
    // Should not contain *.bak pattern
    expect(gitignoreContent).not.toContain('*.bak');
    
    // Should still contain the main generated file path
    expect(gitignoreContent).toContain('AGENTS.md');
  });

  it('adds .bak paths to .gitignore with --backup (default)', async () => {
    const { projectRoot } = testProject;
    const gitignoreFile = path.join(projectRoot, '.gitignore');
    
    runRuler('apply --backup', projectRoot);
    
    // Check .gitignore content
    const gitignoreContent = await fs.readFile(gitignoreFile, 'utf8');
    
    // Should contain specific backup paths but NOT the broad *.bak pattern
    expect(gitignoreContent).toContain('/AGENTS.md.bak');
    expect(gitignoreContent).not.toContain('*.bak');
  });

  describe('agents with custom applyRulerConfig implementations', () => {
    it('AgentsMdAgent respects --no-backup flag', async () => {
      const testProject = await setupTestProject({
        '.ruler/AGENTS.md': '# Test Rules for AgentsMd\nCustom rules for AGENTS.md',
        '.ruler/ruler.toml': 'default_agents = ["agentsmd"]\n',
        'AGENTS.md': '# Existing AGENTS.md\nThis should not be backed up.',
      });
      
      try {
        const { projectRoot } = testProject;
        const backupFile = path.join(projectRoot, 'AGENTS.md.bak');
        
        runRuler('apply --no-backup', projectRoot);
        
        // Check that backup file was NOT created
        const backupExists = await fs.access(backupFile).then(() => true).catch(() => false);
        expect(backupExists).toBe(false);
        
        // Check that the target file was still updated
        const targetContent = await fs.readFile(path.join(projectRoot, 'AGENTS.md'), 'utf8');
        expect(targetContent).toContain('<!-- Generated by Ruler -->');
        expect(targetContent).toContain('Test Rules for AgentsMd');
      } finally {
        await teardownTestProject(testProject.projectRoot);
      }
    });

    it('WindsurfAgent respects --no-backup flag', async () => {
      const testProject = await setupTestProject({
        '.ruler/AGENTS.md': '# Test Rules for Windsurf\nCustom windsurf rules',
        '.ruler/ruler.toml': 'default_agents = ["windsurf"]\n',
      });
      
      try {
        const { projectRoot } = testProject;
        const targetFile = path.join(projectRoot, 'AGENTS.md');
        const backupFile = path.join(projectRoot, 'AGENTS.md.bak');
        
        // Create existing file to be potentially backed up
        await fs.writeFile(targetFile, '# Existing Windsurf Rules\nShould not be backed up.');
        
        runRuler('apply --no-backup', projectRoot);
        
        // Check that backup file was NOT created
        const backupExists = await fs.access(backupFile).then(() => true).catch(() => false);
        expect(backupExists).toBe(false);
        
        // Check that the target file was still updated
        const targetContent = await fs.readFile(targetFile, 'utf8');
        expect(targetContent).toContain('<!-- Generated by Ruler -->');
        expect(targetContent).toContain('Test Rules for Windsurf');
      } finally {
        await teardownTestProject(testProject.projectRoot);
      }
    });

    it('CursorAgent respects --no-backup flag', async () => {
      const testProject = await setupTestProject({
        '.ruler/AGENTS.md': '# Test Rules for Cursor\nCustom cursor rules',
        '.ruler/ruler.toml': 'default_agents = ["cursor"]\n',
      });

      try {
        const { projectRoot } = testProject;
        const targetFile = path.join(projectRoot, 'AGENTS.md');
        const backupFile = path.join(projectRoot, 'AGENTS.md.bak');

        // Create existing file to be potentially backed up
        await fs.writeFile(targetFile, '# Existing Cursor Rules\nShould not be backed up.');

        runRuler('apply --no-backup', projectRoot);

        // Check that backup file was NOT created
        const backupExists = await fs.access(backupFile).then(() => true).catch(() => false);
        expect(backupExists).toBe(false);

        // Check that the target file was still updated
        const targetContent = await fs.readFile(targetFile, 'utf8');
        expect(targetContent).toContain('<!-- Generated by Ruler -->');
        expect(targetContent).toContain('Test Rules for Cursor');
      } finally {
        await teardownTestProject(testProject.projectRoot);
      }
    });

    it('AugmentCodeAgent respects --no-backup flag', async () => {
      const testProject = await setupTestProject({
        '.ruler/AGENTS.md': '# Test Rules for AugmentCode\nCustom augmentcode rules',
        '.ruler/ruler.toml': 'default_agents = ["augmentcode"]\n',
      });
      
      try {
        const { projectRoot } = testProject;
        const targetFile = path.join(projectRoot, '.augment', 'rules', 'ruler_augment_instructions.md');
        const backupFile = path.join(projectRoot, '.augment', 'rules', 'ruler_augment_instructions.md.bak');
        
        // Create existing file to be potentially backed up
        await fs.mkdir(path.dirname(targetFile), { recursive: true });
        await fs.writeFile(targetFile, '# Existing AugmentCode Rules\nShould not be backed up.');
        
        runRuler('apply --no-backup', projectRoot);
        
        // Check that backup file was NOT created
        const backupExists = await fs.access(backupFile).then(() => true).catch(() => false);
        expect(backupExists).toBe(false);
        
        // Check that the target file was still updated
        const targetContent = await fs.readFile(targetFile, 'utf8');
        expect(targetContent).toContain('Test Rules for AugmentCode');
      } finally {
        await teardownTestProject(testProject.projectRoot);
      }
    });

    it('AiderAgent respects --no-backup flag for both AGENTS.md and .aider.conf.yml', async () => {
      const testProject = await setupTestProject({
        '.ruler/AGENTS.md': '# Test Rules for Aider\nCustom aider rules',
        '.ruler/ruler.toml': 'default_agents = ["aider"]\n',
        'AGENTS.md': '# Existing AGENTS.md\nShould not be backed up.',
        '.aider.conf.yml': 'read:\n  - "existing_file.md"\n',
      });
      
      try {
        const { projectRoot } = testProject;
        const agentsMdBackupFile = path.join(projectRoot, 'AGENTS.md.bak');
        const aiderConfBackupFile = path.join(projectRoot, '.aider.conf.yml.bak');
        
        runRuler('apply --no-backup', projectRoot);
        
        // Check that neither backup file was created
        const agentsMdBackupExists = await fs.access(agentsMdBackupFile).then(() => true).catch(() => false);
        const aiderConfBackupExists = await fs.access(aiderConfBackupFile).then(() => true).catch(() => false);
        expect(agentsMdBackupExists).toBe(false);
        expect(aiderConfBackupExists).toBe(false);
        
        // Check that files were still updated
        const agentsMdContent = await fs.readFile(path.join(projectRoot, 'AGENTS.md'), 'utf8');
        expect(agentsMdContent).toContain('<!-- Generated by Ruler -->');
        expect(agentsMdContent).toContain('Test Rules for Aider');
        
        const aiderConfContent = await fs.readFile(path.join(projectRoot, '.aider.conf.yml'), 'utf8');
        expect(aiderConfContent).toContain('AGENTS.md');
        expect(aiderConfContent).toContain('existing_file.md'); // Preserved existing config
      } finally {
        await teardownTestProject(testProject.projectRoot);
      }
    });

    it('all agents create backups by default', async () => {
      const testProject = await setupTestProject({
        '.ruler/AGENTS.md': '# Test Rules\nGeneric test rules',
        '.ruler/ruler.toml': 'default_agents = ["agentsmd", "windsurf", "cursor", "augmentcode", "aider"]\n',
        'AGENTS.md': '# Existing AGENTS.md\nShould be backed up.',
      });
      
      try {
        const { projectRoot } = testProject;
        
        // Create existing files for agents that need them (Windsurf uses AGENTS.md now)
        const cursorFile = path.join(projectRoot, '.cursor', 'rules', 'ruler_cursor_instructions.mdc');
        const augmentFile = path.join(projectRoot, '.augment', 'rules', 'ruler_augment_instructions.md');
        const aiderConfFile = path.join(projectRoot, '.aider.conf.yml');
        
        await fs.mkdir(path.dirname(cursorFile), { recursive: true });
        await fs.writeFile(cursorFile, 'Existing cursor content');
        await fs.mkdir(path.dirname(augmentFile), { recursive: true });
        await fs.writeFile(augmentFile, 'Existing augment content');
        await fs.writeFile(aiderConfFile, 'read: ["old.md"]');
        
        runRuler('apply', projectRoot); // Default behavior should create backups
        
        // Check that all backup files were created
        // Note: Windsurf and Cursor now use AGENTS.md, so their backup is AGENTS.md.bak
        const expectedBackups = [
          'AGENTS.md.bak',
          '.augment/rules/ruler_augment_instructions.md.bak',
          '.aider.conf.yml.bak',
        ];
        
        for (const backupPath of expectedBackups) {
          const fullPath = path.join(projectRoot, backupPath);
          const exists = await fs.access(fullPath).then(() => true).catch(() => false);
          expect(exists).toBe(true);
        }
      } finally {
        await teardownTestProject(testProject.projectRoot);
      }
    });
  });
});