import * as path from 'path';
import { promises as fs } from 'fs';
import { IAgent } from '../agents/IAgent';
import { IAgentConfig } from './ConfigLoader';
import { getAgentOutputPaths } from '../agents/agent-utils';
import { getNativeMcpPath } from '../paths/mcp';
import { logVerbose } from '../constants';
import {
  readVSCodeSettings,
  writeVSCodeSettings,
  getVSCodeSettingsPath,
} from '../vscode/settings';

/**
 * Result of reverting an agent configuration
 */
export interface RevertAgentResult {
  restored: number;
  removed: number;
  backupsRemoved: number;
}

/**
 * Result of cleaning up auxiliary files
 */
export interface CleanUpResult {
  additionalFilesRemoved: number;
  directoriesRemoved: number;
}

/**
 * Checks if a file exists.
 */
async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Restores a file from its backup if the backup exists.
 */
async function restoreFromBackup(
  filePath: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<boolean> {
  const backupPath = `${filePath}.bak`;
  const backupExists = await fileExists(backupPath);

  if (!backupExists) {
    logVerbose(`No backup found for: ${filePath}`, verbose);
    return false;
  }

  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  if (dryRun) {
    logVerbose(
      `${actionPrefix} Would restore: ${filePath} from backup`,
      verbose,
    );
  } else {
    await fs.copyFile(backupPath, filePath);
    logVerbose(`${actionPrefix} Restored: ${filePath} from backup`, verbose);
  }

  return true;
}

/**
 * Removes a file if it exists and has no backup (meaning it was generated by ruler).
 */
async function removeGeneratedFile(
  filePath: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<boolean> {
  const fileExistsFlag = await fileExists(filePath);
  const backupExists = await fileExists(`${filePath}.bak`);

  if (!fileExistsFlag) {
    logVerbose(`File does not exist: ${filePath}`, verbose);
    return false;
  }

  if (backupExists) {
    logVerbose(`File has backup, skipping removal: ${filePath}`, verbose);
    return false;
  }

  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  if (dryRun) {
    logVerbose(
      `${actionPrefix} Would remove generated file: ${filePath}`,
      verbose,
    );
  } else {
    await fs.unlink(filePath);
    logVerbose(`${actionPrefix} Removed generated file: ${filePath}`, verbose);
  }

  return true;
}

/**
 * Removes backup files.
 */
async function removeBackupFile(
  filePath: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<boolean> {
  const backupPath = `${filePath}.bak`;
  const backupExists = await fileExists(backupPath);

  if (!backupExists) {
    return false;
  }

  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  if (dryRun) {
    logVerbose(
      `${actionPrefix} Would remove backup file: ${backupPath}`,
      verbose,
    );
  } else {
    await fs.unlink(backupPath);
    logVerbose(`${actionPrefix} Removed backup file: ${backupPath}`, verbose);
  }

  return true;
}

/**
 * Recursively checks if a directory contains only empty directories
 */
async function isDirectoryTreeEmpty(dirPath: string): Promise<boolean> {
  try {
    const entries = await fs.readdir(dirPath);
    if (entries.length === 0) {
      return true;
    }

    for (const entry of entries) {
      const entryPath = path.join(dirPath, entry);
      const entryStat = await fs.stat(entryPath);

      if (entryStat.isFile()) {
        return false;
      } else if (entryStat.isDirectory()) {
        const isEmpty = await isDirectoryTreeEmpty(entryPath);
        if (!isEmpty) {
          return false;
        }
      }
    }

    return true;
  } catch {
    return false;
  }
}

/**
 * Helper function to execute directory removal with consistent dry-run handling and logging.
 */
async function executeDirectoryAction(
  dirPath: string,
  action: 'remove' | 'remove-tree',
  verbose: boolean,
  dryRun: boolean,
): Promise<boolean> {
  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';
  const actionText = action === 'remove-tree' ? 'directory tree' : 'directory';

  if (dryRun) {
    logVerbose(
      `${actionPrefix} Would remove empty ${actionText}: ${dirPath}`,
      verbose,
    );
  } else {
    await fs.rm(dirPath, { recursive: true });
    logVerbose(
      `${actionPrefix} Removed empty ${actionText}: ${dirPath}`,
      verbose,
    );
  }
  return true;
}

/**
 * Attempts to remove a single empty directory if it exists and is empty.
 */
async function removeEmptyDirectory(
  dirPath: string,
  verbose: boolean,
  dryRun: boolean,
  logMissing = false,
): Promise<boolean> {
  try {
    const stat = await fs.stat(dirPath);
    if (!stat.isDirectory()) {
      return false;
    }

    const isEmpty = await isDirectoryTreeEmpty(dirPath);
    if (isEmpty) {
      return await executeDirectoryAction(
        dirPath,
        'remove-tree',
        verbose,
        dryRun,
      );
    }
    return false;
  } catch {
    if (logMissing) {
      logVerbose(
        `Directory ${dirPath} doesn't exist or can't be accessed`,
        verbose,
      );
    }
    return false;
  }
}

/**
 * Handles special cleanup logic for .augment directory and its rules subdirectory.
 */
async function removeAugmentDirectory(
  projectRoot: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<number> {
  const augmentDir = path.join(projectRoot, '.augment');
  let directoriesRemoved = 0;

  try {
    const augmentStat = await fs.stat(augmentDir);
    if (!augmentStat.isDirectory()) {
      return 0;
    }

    const rulesDir = path.join(augmentDir, 'rules');
    const rulesRemoved = await removeEmptyDirectory(rulesDir, verbose, dryRun);
    if (rulesRemoved) {
      directoriesRemoved++;
    }

    const augmentRemoved = await removeEmptyDirectory(
      augmentDir,
      verbose,
      dryRun,
    );
    if (augmentRemoved) {
      directoriesRemoved++;
    }
  } catch {
    // .augment directory doesn't exist, that's fine. leaving comment as catch block can't be kept empty.
  }

  return directoriesRemoved;
}

/**
 * Removes empty directories that were created by ruler.
 * Only removes directories if they are empty and were likely created by ruler.
 * Special handling for .augment directory to clean up rules subdirectory.
 */
async function removeEmptyDirectories(
  projectRoot: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<number> {
  const rulerCreatedDirs = [
    '.github',
    '.cursor',
    '.windsurf',
    '.junie',
    '.openhands',
    '.idx',
    '.gemini',
    '.vscode',
    '.codex',
    '.kilocode',
  ];

  let directoriesRemoved = 0;

  // Handle .augment directory with special logic
  directoriesRemoved += await removeAugmentDirectory(
    projectRoot,
    verbose,
    dryRun,
  );

  // Handle all other ruler-created directories
  for (const dirName of rulerCreatedDirs) {
    const dirPath = path.join(projectRoot, dirName);
    const removed = await removeEmptyDirectory(dirPath, verbose, dryRun, true);
    if (removed) {
      directoriesRemoved++;
    }
  }

  return directoriesRemoved;
}

/**
 * Removes additional files created by specific agents that aren't covered by their main output paths.
 */
async function removeAdditionalAgentFiles(
  projectRoot: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<number> {
  const additionalFiles = [
    '.gemini/settings.json',
    '.mcp.json',
    '.vscode/mcp.json',
    '.cursor/mcp.json',
    '.kilocode/mcp.json',
    '.openhands/config.toml',
  ];

  let filesRemoved = 0;
  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  for (const filePath of additionalFiles) {
    const fullPath = path.join(projectRoot, filePath);

    try {
      const fileExistsFlag = await fileExists(fullPath);
      if (!fileExistsFlag) {
        continue;
      }

      const backupExists = await fileExists(`${fullPath}.bak`);
      if (backupExists) {
        const restored = await restoreFromBackup(fullPath, verbose, dryRun);
        if (restored) {
          filesRemoved++;
        }
      } else {
        if (dryRun) {
          logVerbose(
            `${actionPrefix} Would remove additional file: ${fullPath}`,
            verbose,
          );
        } else {
          await fs.unlink(fullPath);
          logVerbose(
            `${actionPrefix} Removed additional file: ${fullPath}`,
            verbose,
          );
        }
        filesRemoved++;
      }
    } catch {
      logVerbose(
        `Additional file ${fullPath} doesn't exist or can't be accessed`,
        verbose,
      );
    }
  }

  const settingsPath = getVSCodeSettingsPath(projectRoot);
  const backupPath = `${settingsPath}.bak`;

  if (await fileExists(backupPath)) {
    const restored = await restoreFromBackup(settingsPath, verbose, dryRun);
    if (restored) {
      filesRemoved++;
      logVerbose(
        `${actionPrefix} Restored VSCode settings from backup`,
        verbose,
      );
    }
  } else if (await fileExists(settingsPath)) {
    try {
      if (dryRun) {
        const settings = await readVSCodeSettings(settingsPath);
        if (settings['augment.advanced']) {
          delete settings['augment.advanced'];
          const remainingKeys = Object.keys(settings);
          if (remainingKeys.length === 0) {
            logVerbose(
              `${actionPrefix} Would remove empty VSCode settings file`,
              verbose,
            );
          } else {
            logVerbose(
              `${actionPrefix} Would remove augment.advanced section from ${settingsPath}`,
              verbose,
            );
          }
          filesRemoved++;
        }
      } else {
        const settings = await readVSCodeSettings(settingsPath);
        if (settings['augment.advanced']) {
          delete settings['augment.advanced'];

          const remainingKeys = Object.keys(settings);
          if (remainingKeys.length === 0) {
            await fs.unlink(settingsPath);
            logVerbose(
              `${actionPrefix} Removed empty VSCode settings file`,
              verbose,
            );
          } else {
            await writeVSCodeSettings(settingsPath, settings);
            logVerbose(
              `${actionPrefix} Removed augment.advanced section from VSCode settings`,
              verbose,
            );
          }
          filesRemoved++;
        } else {
          logVerbose(
            `No augment.advanced section found in ${settingsPath}`,
            verbose,
          );
        }
      }
    } catch (error) {
      logVerbose(`Failed to process VSCode settings.json: ${error}`, verbose);
    }
  }

  return filesRemoved;
}

/**
 * Reverts configuration for a single agent.
 * @param agent The agent to revert
 * @param projectRoot Root directory of the project
 * @param agentConfig Agent-specific configuration
 * @param keepBackups Whether to keep backup files
 * @param verbose Whether to enable verbose logging
 * @param dryRun Whether to perform a dry run
 * @returns Promise resolving to revert statistics
 */
export async function revertAgentConfiguration(
  agent: IAgent,
  projectRoot: string,
  agentConfig: IAgentConfig | undefined,
  keepBackups: boolean,
  verbose: boolean,
  dryRun: boolean,
): Promise<RevertAgentResult> {
  const result: RevertAgentResult = {
    restored: 0,
    removed: 0,
    backupsRemoved: 0,
  };

  const outputPaths = getAgentOutputPaths(agent, projectRoot, agentConfig);

  logVerbose(
    `Agent ${agent.getName()} output paths: ${outputPaths.join(', ')}`,
    verbose,
  );

  for (const outputPath of outputPaths) {
    const restored = await restoreFromBackup(outputPath, verbose, dryRun);
    if (restored) {
      result.restored++;

      if (!keepBackups) {
        const backupRemoved = await removeBackupFile(
          outputPath,
          verbose,
          dryRun,
        );
        if (backupRemoved) {
          result.backupsRemoved++;
        }
      }
    } else {
      const removed = await removeGeneratedFile(outputPath, verbose, dryRun);
      if (removed) {
        result.removed++;
      }
    }
  }

  // Handle MCP files
  const mcpPath = await getNativeMcpPath(agent.getName(), projectRoot);
  if (mcpPath && mcpPath.startsWith(projectRoot)) {
    if (
      agent.getName() === 'AugmentCode' &&
      mcpPath.endsWith('.vscode/settings.json')
    ) {
      logVerbose(
        `Skipping MCP handling for AugmentCode settings.json - handled separately`,
        verbose,
      );
    } else {
      const mcpRestored = await restoreFromBackup(mcpPath, verbose, dryRun);
      if (mcpRestored) {
        result.restored++;

        if (!keepBackups) {
          const mcpBackupRemoved = await removeBackupFile(
            mcpPath,
            verbose,
            dryRun,
          );
          if (mcpBackupRemoved) {
            result.backupsRemoved++;
          }
        }
      } else {
        const mcpRemoved = await removeGeneratedFile(mcpPath, verbose, dryRun);
        if (mcpRemoved) {
          result.removed++;
        }
      }
    }
  }

  return result;
}

/**
 * Cleans up auxiliary files and directories.
 * @param projectRoot Root directory of the project
 * @param verbose Whether to enable verbose logging
 * @param dryRun Whether to perform a dry run
 * @returns Promise resolving to cleanup statistics
 */
export async function cleanUpAuxiliaryFiles(
  projectRoot: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<CleanUpResult> {
  const additionalFilesRemoved = await removeAdditionalAgentFiles(
    projectRoot,
    verbose,
    dryRun,
  );

  const directoriesRemoved = await removeEmptyDirectories(
    projectRoot,
    verbose,
    dryRun,
  );

  return {
    additionalFilesRemoved,
    directoriesRemoved,
  };
}
